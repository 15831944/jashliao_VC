#include<stdio.h>

#define BUFFER_SIZE 102400
#define TRUE 1

typedef unsigned char byte;

unsigned char buffer[BUFFER_SIZE];

int encode(FILE *fp,byte *img,int mx);

/* main函數 */
int main(int ac,char *av[])
{
    FILE *fp_i,*fp_o;
    int i,c;

    if(ac<3) {
        exit(8);
    }
    fp_i=fopen(av[1],"rb");
    if(fp_i==NULL) {
        fprintf(stderr,"Input File cannot open\n");
        exit(8);
    }
    i=0;
    while(i<BUFFER_SIZE && (c=fgetc(fp_i))!=EOF) {
        buffer[i]=c;
        i++;
    }
    fclose(fp_i);
    fp_o=fopen(av[2],"wb");
    if(fp_o==NULL) {
        fprintf(stderr,"Output File cannot open\n");
        exit(8);
    }
    encode(fp_o,buffer,i);
    fclose(fp_o);
    return 0;
}

/* 求出x的正負符號 */
int sgni(int x)
{
    if(x<0) return -1;
    if(x>0) return 1;
    return 0;
}

/* 求出x的絕對值 */
int absi(int x)
{
    if(x<0) return -x;
    return x;
}

/* 將4位元組的數值資料從檔案輸出 */
int fputLong(long num,FILE *fp)
{
    fputc((num>>24) & 0xff,fp);
    fputc((num>>16) & 0xff,fp);
    fputc((num>>8)  & 0xff,fp);
    fputc((num)     & 0xff,fp);
    return 0;
}

#define N 256
#define NODATA 2100000000

/* 霍夫曼樹用的陣列 */
int l_node[2*N],r_node[2*N];
int parent[2*N];

/* 將出現頻率表輸出到檔案 */
int outputHist(int *hist,int nn,FILE *fp)
{
    int i;

    for(i=0;i<nn;i++)
        fputLong(hist[i],fp);
    return TRUE;
}

/* 求出頻率最小的兩者 */
int getMin2(int *hist,int hm,int *d1,int *d2)
{
    int i;
    int min;

    min=NODATA-1;
    *d1= *d2= -100;
    for(i=0;i<hm;i++) {
        if(hist[i]<min) {
            *d1=i;
            min=hist[i];
        }
    }
    min=NODATA-1;
    for(i=0;i<hm;i++) {
        if(i!=(*d1) && hist[i]<min) {
            *d2=i;
            min=hist[i];
        }
    }
    return 0;
}

/* 製作霍夫曼樹 */
int makeTree(int *hist,int n)
{
    int hm_data;
    int d1,d2,i;

    hm_data=n;

    /* 初始化 */
    for(i=0;i<2+N;i++) {
        l_node[i]=r_node[i]=parent[i]=0;
    }

    while(1) {
        /* 求出頻率最小的兩者 */
        getMin2(hist,hm_data,&d1,&d2);
        /* 若沒有最小值，則結束 */
        if(d1<0 || d2<0) break;
        l_node[hm_data]=d1;
        r_node[hm_data]=d2;
        parent[d1]=hm_data;
        parent[d2]= -hm_data;
        hist[hm_data]=hist[d1]+hist[d2];
        hist[d1]=NODATA;
        hist[d2]=NODATA;
        hm_data++;
    }
    return hm_data;
}

static int bits=0;
static int bdata=0;

/* 位元輸出處理的初始化 */
int fputBitInit()
{
    bits=0;
    bdata=0;
    return 0;
}

/* 輸出1位元 */
int fputBit(int bit,FILE *fp)
{
    bdata=(bdata<<1)|bit;
    bits++;
    if(bits>=8) {
        fputc(bdata,fp);
        bits=0;
        bdata=0;
    }
    return 0;
}

/* 將多餘的位元輸出 */
int flushBit(FILE *fp)
{
    int i;

    for(i=0;i<7;i++) {
        fputBit(0,fp);
    }
    return 0;
}

/* 輸出霍夫曼編碼 */
int outputEncode(int val,int end,FILE *fp)
{
    int c;
    int code[100];
    int now,i;
    int s1,a1;

    c=0;
    now=val;
    while(1) {
        s1=sgni(parent[now]);
        a1=absi(parent[now]);
        if(s1<0) code[c++]=1;
        else code[c++]=0;
        if(a1==end-1) break;
        now=a1;
    }
    for(i=c-1;i>=0;i--) {
        fputBit(code[i],fp);
    }
    return 0;
}

/* 壓縮處理主程式 */
int encode(FILE *fpo,unsigned char *data,int size)
{
    int i;
    int datas;
    int hist[N*2];

    /* 求出各資料值的出現頻率 */
    for(i=0;i<N*2;i++) hist[i]=0;
    for(i=0;i<size;i++) hist[data[i]]++;
    fputLong(size,fpo);
    outputHist(hist,N,fpo);
    datas=makeTree(hist,N);
    fputBitInit();
    for(i=0;i<size;i++) {
        outputEncode(data[i],datas,fpo);
    }
    flushBit(fpo);
    return 0;
}
