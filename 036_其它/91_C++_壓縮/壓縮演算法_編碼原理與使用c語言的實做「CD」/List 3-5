#include <stdio.h>
#include <stdlib.h>

#define BUFFER_SIZE 102400
#define TRUE 1
#define FALSE 0

typedef unsigned char byte;

unsigned char buffer[BUFFER_SIZE];

/* main函數 */
int main(int ac,char *av[])
{
    FILE *fp_i,*fp_o;
    int i,c;
    int dic,code;

    if(ac<5) {
        exit(8);
    }
    fp_i=fopen(av[1],"rb");
    if(fp_i==NULL) {
        fprintf(stderr,"Input File cannot open\n");
        exit(8);
    }
    i=0;
    while(i<BUFFER_SIZE && (c=fgetc(fp_i))!=EOF) {
        buffer[i]=c;
        i++;
    }
    fclose(fp_i);
    fp_o=fopen(av[2],"wb");
    if(fp_o==NULL) {
        fprintf(stderr,"Output File cannot open\n");
        exit(8);
    }
    dic=atoi(av[3]);
    code=atoi(av[4]);
    encode(fp_o,buffer,i,dic,code);
    fclose(fp_o);
}

/* 將4位元組的數值資料輸出到檔案 */
int fputLong(long num,FILE *fp)
{
    fputc((num>>24) & 0xff,fp);
    fputc((num>>16) & 0xff,fp);
    fputc((num>>8)  & 0xff,fp);
    fputc((num)     & 0xff,fp);
    return 0;
}

static int bits=0;
static int bdata=0;

/* 輸出處理的初始化 */
int fputBitInit()
{
    bits=0;
    bdata=0;
    return 0;
}

/* 輸出1位元 */
int fputBit(int bit,FILE *fp)
{
    bdata=(bdata<<1)|bit;
    bits++;
    if(bits>=8) {
        fputc(bdata,fp);
        bits=0;
        bdata=0;
    }
    return 0;
}

/* 輸出n位元 */
int putBits(FILE *fp,int data,int n)
{
    int i;

    for(i=n-1;i>=0;i--) {
        fputBit((data>>i)&1,fp);
    }
    return 0;
}

/* 將多餘的位元輸出 */
int flushBit(FILE *fp)
{
    int i;

    for(i=0;i<7;i++) {
        fputBit(0,fp);
    }
    return 0;
}

/* 辭典緩衝區 */
typedef int BUF;
typedef struct SDIC
{
    BUF *buffer;
    int dic_len,code_len;    /* 辭典大小與編碼大小 */
    int buf_size;            /* 緩衝區整體的大小 */
    int dic_bgn;             /* 辭典部分的開始 */
    int code_bgn,code_end;   /* 編碼部分的開始與結束 */
}SlideDic;

/* 求出滑動辭典中的下一個資料位置 */
int nextPos(int now,int bsize)
{
    return (now+1)%bsize;
}

/* 滑動辭典的初始化 */
int initSlideDic(SlideDic *sdic,int dic,int code)
{
    int i;
    int size;

    size=dic+code;
    if((sdic->buffer=malloc(sizeof(BUF)*size))==NULL) return FALSE;
    for(i=0;i<size;i++) sdic->buffer[i]=0;
    sdic->dic_len=dic;
    sdic->code_len=code;
    sdic->buf_size=size;
    sdic->dic_bgn=0;
    sdic->code_bgn=0;
    sdic->code_end=0;
    return TRUE;
}

/* 從辭典的第pos個位置求出一致的長度 */
int getMatchLength(SlideDic *sdic,int pos)
{
    int len;
    int codes;
    int i;
    int t,u;

    len=0;
    t=pos;
    u=sdic->code_bgn;
    codes=sdic->code_end - sdic->code_bgn;
    if(codes<0) codes+=sdic->buf_size;
    for(i=0;i<codes;i++) {
        if(sdic->buffer[t] != sdic->buffer[u]) break;
        len++;
        t=nextPos(t,sdic->buf_size);
        u=nextPos(u,sdic->buf_size);
    }
    return len;
}

/* 從辭典裡面找出，一致字串中長度最長者 */
/* 將位置和長度各傳回給pos和len */
int getMatchPattern(SlideDic *sdic,int *pos,int *len)
{
    int i;
    int len1;

    *pos=-1;
    *len=-1;
    for(i=sdic->dic_bgn;i!=sdic->code_bgn;i=nextPos(i,sdic->buf_size)) {
        len1=getMatchLength(sdic,i);
        if(*len<len1) {
            *len=len1;
            *pos=i - sdic->dic_bgn;
        }
    }
    if(*pos<0) *pos += sdic->buf_size;
    return 0;
}

/* 在辭典緩衝區追加1個字 */
int insertCodeToDic(SlideDic *sdic,int c)
{
    int bsize;

    bsize=sdic->buf_size;

    sdic->buffer[sdic->code_end]=c;
    sdic->code_end =nextPos(sdic->code_end,bsize);
    return 0;
}

/* 將辭典緩衝區往後滑動 */
int slideDic(SlideDic *sdic)
{
    int dic_next;
    int dic_size;

    dic_size= sdic->code_bgn - sdic->dic_bgn;
    if(dic_size<0) dic_size+= sdic->buf_size;
    sdic->code_bgn =nextPos(sdic->code_bgn,sdic->buf_size);

    if(dic_size>=sdic->dic_len) {
        dic_next=nextPos(sdic->dic_bgn,sdic->buf_size);
        sdic->dic_bgn = dic_next;
    }
    return 0;
}

/* 壓縮處理主程式 */
int encode(FILE *fp,unsigned char *data,int dsize,int dic_bits,int code_bits)
{
    SlideDic sdic;
    int dic,code;
    int init_size;
    int pos,len;
    int i,p;

    dic=getPow2(dic_bits);
    code=getPow2(code_bits)+2;
    initSlideDic(&sdic,dic,code);
    if(dsize<code) init_size=dsize;
    else init_size=code;

    p=0;
    for(i=0;i<init_size;i++) {
        insertCodeToDic(&sdic,data[p++]);
    }
    fputLong(dsize,fp);
    fputLong(dic_bits,fp);
    fputLong(code_bits,fp);
    fputBitInit();
    while(sdic.code_bgn!=sdic.code_end) {
        getMatchPattern(&sdic,&pos,&len);
        if(len>2) {
            putBits(fp,1,1);
            putBits(fp,pos,dic_bits);
            putBits(fp,len-3,code_bits);
        }
        else {
            putBits(fp,0,1);
            putBits(fp,sdic.buffer[sdic.code_bgn],8);
            len=1;
        }
        for(i=0;i<len;i++) {
            if(p<dsize)
                insertCodeToDic(&sdic,data[p++]);
            /*else {
                if(dic<dsize)
                    sdic.dic_bgn=nextPos(sdic.dic_bgn,sdic.buf_size);
            }*/
            slideDic(&sdic);
        }
    }
    flushBit(fp);
    return 0;
}

/* 求出記錄所需的最小位元長度 */
int getBitLength(int x)
{
    if(x<   2) return 1;
    if(x<   4) return 2;
    if(x<   8) return 3;
    if(x<  16) return 4;
    if(x<  32) return 5;
    if(x<  64) return 6;
    if(x< 128) return 7;
    if(x< 256) return 8;
    if(x< 512) return 9;
    if(x<1024) return 10;
    if(x<2048) return 11;
    if(x<4096) return 12;
    if(x<8192) return 13;
    if(x<16384) return 14;
    if(x<32768) return 15;
    if(x<65536) return 16;
    printf("ERR");
    return -1;
}

/* 求出2的x次方 */
int getPow2(int x)
{
    int i;
    int s;

    s=1;
    for(i=0;i<x;i++) s*=2;
    return s;
}
