#include <stdlib.h>

#define NNN 8

#include <windows.h>
#include <stdio.h>
#include <math.h>

#define SUPPORT_1    1
#define SUPPORT_2    2
#define SUPPORT_4    4
#define SUPPORT_8    8
#define SUPPORT_16   16
#define SUPPORT_24   32
#define SUPPORT_32   64

#define PAI 3.14159265
#define M_PI PAI

char pbuf[256];

/* 傳回plug-in的資訊 */
int WINAPI GetAddinInfo(int infon,LPSTR str,int strl)
{
    switch(infon) {
    case 0:
        strncpy(str,"00XN",strl);
        break;
    case 1:
        strncpy(str,"DCT Encode Ver0.01 By Kz",strl);
        break;
    case 2:
        strncpy(str,"*.DCT",strl);
        break;
    case 3:
        strncpy(str,"DCT",strl);
        break;
    default:
        return 0;
    }
    return strlen(str);
}

/* 傳回支援的圖像類型 */
int WINAPI SupportImage(void)
{
    return SUPPORT_24;
}

/*************************************************************/
/* 將圖像資料輸出到檔案 */
int WINAPI WritePicture(
              LPSTR *fname,
              unsigned int flag,
              BITMAPINFO *pHBInfo,void* pHBm,
              FARPROC lpPrgressCallback,int ac,char *av[])
{
    FILE *fp;
    BITMAPINFOHEADER *bmih;
    byte *img;
    int mx,my,dep;

    bmih=(BITMAPINFOHEADER *)pHBInfo;
    img=pHBm;
    mx=bmih->biWidth;
    my=bmih->biHeight;
    dep=bmih->biBitCount;

    if((fp=fopen((char*)fname,"wb"))==NULL) return FALSE;

    if(lpPrgressCallback) lpPrgressCallback(0,0,0);

    switch(dep) {
    case 24:
        outputHeader(fp,mx,my,dep);
        encode(fp,img,mx,my);
        break;
    default:
        MessageBox(NULL,"Not support!","ERR",MB_OK);
        return 1;
    }
    if(lpPrgressCallback) lpPrgressCallback(my,my,0);
    fclose(fp);
    return 0;
}

/* 將4位元組的數值資料輸出到檔案 */
int fputLong(long num,FILE *fp)
{
    fputc((num>>24) & 0xff,fp);
    fputc((num>>16) & 0xff,fp);
    fputc((num>>8)  & 0xff,fp);
    fputc((num)     & 0xff,fp);
    return 0;
}

/* 將2位元組的數值資料輸出到檔案 */
int fputShort(signed short num,FILE *fp)
{
    fputc((num>>8)  & 0xff,fp);
    fputc((num)     & 0xff,fp);
    return 0;
}

/* 輸出標頭資訊 */
int outputHeader(FILE *fp,int mx,int my,int dep)
{
    fputc('D',fp);
    fputc('C',fp);
    fputc('T',fp);
    fputc('1',fp);
    fputLong(mx,fp);
    fputLong(my,fp);
    return 0;
}

static int bits=0;
static int bdata=0;

/* 輸出處理的初始化 */
int fputBitInit()
{
    bits=0;
    bdata=0;
    return 0;
}

/* 輸出1位元 */
int fputBit(int bit,FILE *fp)
{
    bdata=(bdata<<1)|bit;
    bits++;
    if(bits>=8) {
        fputc(bdata,fp);
        bits=0;
        bdata=0;
    }
    return 0;
}

/* 輸出n位元 */
int putBits(FILE *fp,int data,int n)
{
    int i;

    for(i=n-1;i>=0;i--) {
        fputBit((data>>i)&1,fp);
    }
    return 0;
}

/* 將多餘的位元輸出 */
int flushBit(FILE *fp)
{
    int i;

    for(i=0;i<7;i++) {
        fputBit(0,fp);
    }
    return 0;
}

/* 使用任意位元數來輸出 */
int fputNumber(int num,int bits,FILE *fp)
{
    if(num<0) {
        fputBit(1,fp);
        num= -num;
    }
    else {
        fputBit(0,fp);
    }
    putBits(fp,num,bits);
    return 0;
}

/* 存放RGB值的資料結構 */
typedef struct RGB_COL{
    int r,g,b;
}RGBcolor;

/* 取得24位元DIB上的像素值 */
int getColor(int x,int y,unsigned char *data,int mx,int my,RGBcolor *col)
{
    int adr,mmx;

    mmx=(mx*3+3)/4*4;
    if(x>=mx) x=mx-1;
    if(y>=my) y=my-1;
    adr=x*3+(my-y-1)*mmx;
    col->r=data[adr+2];
    col->g=data[adr+1];
    col->b=data[adr];
    return 0;
}

/* 求出轉置矩陣 */
int tenchi(double *mat,int n)
{
    int x,y;
    double tmp;

    for(y=0;y<n;y++) {
        for(x=0;x<n;x++) {
            if(x<y) {
                tmp=mat[x+y*n];
                mat[x+y*n]=mat[y+x*n];
                mat[y+x*n]=tmp;
            }
        }
    }
    return 0;
}

/* 壓縮處理主程式 */
int encode(FILE *fp,unsigned char *data,int mx,int my)
{
    int x,y;
    int lx,ly,loopx,loopy;
    double r_re[NNN*NNN],b[NNN*NNN],c[NNN*NNN];
    RGBcolor col;

    loopx=(mx+NNN-1)/NNN;
    loopy=(my+NNN-1)/NNN;
    fputBitInit();
    initConst();
    for(ly=0;ly<loopy;ly++) {
        for(lx=0;lx<loopx;lx++) {
            /* 製作緩衝區 */
            for(y=0;y<NNN;y++) {
                for(x=0;x<NNN;x++) {
                    getColor(lx*NNN+x,ly*NNN+y,data,mx,my,&col);
                    r_re[x+y*NNN]=(double)(col.r);
                }
            }

            for(y=0;y<8;y++) {
                DCT8(r_re+y*8,b+y*8);
            }
            tenchi(b,8);
            for(y=0;y<8;y++) {
                DCT8(b+y*8,c+y*8);
            }

            for(y=0;y<NNN;y++) {
                for(x=0;x<NNN;x++) {
                    fputNumber((int)(c[x+y*NNN]),15,fp);
                }
            }
        }
    }
    flushBit(fp);
    return 0;
}

double c14;
double s18;
double c18;
double s38;
double c38;
double s1h;
double c1h;
double s5h;
double c5h;
double s3h;
double c3h;
double s7h;
double c7h;

/* 定義常數 */
initConst()
{
    c14=cos(  M_PI/4);
    s18=sin(  M_PI/8);
    c18=cos(  M_PI/8);
    s38=sin(3*M_PI/8);
    c38=cos(3*M_PI/8);
    s1h=sin(  M_PI/16);
    c1h=cos(  M_PI/16);
    s5h=sin(5*M_PI/16);
    c5h=cos(5*M_PI/16);
    s3h=sin(3*M_PI/16);
    c3h=cos(3*M_PI/16);
    s7h=sin(7*M_PI/16);
    c7h=cos(7*M_PI/16);
    return 0;
}

/* 對8個資料執行DCT */
int DCT8( double *in, double *out)
{
    double tmp0,tmp1,tmp2,tmp3;
    double tmp4,tmp5,tmp6,tmp7;
    double u4, u5, u6, u7;

    tmp0 = in[0] + in[7];
    tmp1 = in[1] + in[6];
    tmp2 = in[2] + in[5];
    tmp3 = in[3] + in[4];
    tmp4 = in[3] - in[4];
    tmp5 = in[2] - in[5];
    tmp6 = in[1] - in[6];
    tmp7 = in[0] - in[7];

    out[ 0 ] =  (tmp0 + tmp3) * c14 + (tmp1 + tmp2) * c14;
    out[ 4 ] =  (tmp0 + tmp3) * c14 - (tmp1 + tmp2) * c14;
    out[ 2 ] =  (tmp1 - tmp2) * s18 + (tmp0 - tmp3) * c18;
    out[ 6 ] = -(tmp1 - tmp2) * s38 + (tmp0 - tmp3) * c38;

    u4 =  tmp4;
    u5 = -tmp5 * c14 + tmp6 * c14;
    u6 =  tmp5 * c14 + tmp6 * c14;
    u7 =  tmp7;

    tmp4 =  u4 + u5;
    tmp5 =  u4 - u5;
    tmp6 = -u6 + u7;
    tmp7 =  u6 + u7;

    out[ 1 ] =  tmp4 * s1h + tmp7 * c1h;
    out[ 5 ] =  tmp5 * s5h + tmp6 * c5h;
    out[ 3 ] = -tmp5 * s3h + tmp6 * c3h;
    out[ 7 ] = -tmp4 * s7h + tmp7 * c7h;
    return 0;
}
