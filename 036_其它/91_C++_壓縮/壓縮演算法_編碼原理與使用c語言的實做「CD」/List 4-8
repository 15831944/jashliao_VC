#include <stdlib.h>

#define NNN 8
#define Nketa 3

#include <windows.h>
#include <stdio.h>

#define SUPPORT_1    1
#define SUPPORT_2    2
#define SUPPORT_4    4
#define SUPPORT_8    8
#define SUPPORT_16   16
#define SUPPORT_24   32
#define SUPPORT_32   64

#define PAI 3.14159265

char pbuf[256];

/* 傳回plug-in資訊 */
int WINAPI GetAddinInfo(int infon,LPSTR str,int strl)
{
    switch(infon) {
    case 0:
        strncpy(str,"00XN",strl);
        break;
    case 1:
        strncpy(str,"Hadamard Encode 2 Ver0.01 By Kz",strl);
        break;
    case 2:
        strncpy(str,"*.HD2",strl);
        break;
    case 3:
        strncpy(str,"HD2",strl);
        break;
    default:
        return 0;
    }
    return strlen(str);
}

/* 傳回支援的圖像類型 */
int WINAPI SupportImage(void)
{
    return SUPPORT_24;
}

/*************************************************************/
/* 將圖像資料輸出到檔案 */
int WINAPI WritePicture(
              LPSTR *fname,
              unsigned int flag,
              BITMAPINFO *pHBInfo,void* pHBm,
              FARPROC lpPrgressCallback,int ac,char *av[])
{
    FILE *fp;
    BITMAPINFOHEADER *bmih;
    byte *img;
    int mx,my,dep;

    bmih=(BITMAPINFOHEADER *)pHBInfo;
    img=pHBm;
    mx=bmih->biWidth;
    my=bmih->biHeight;
    dep=bmih->biBitCount;

    if((fp=fopen((char*)fname,"wb"))==NULL) return FALSE;

    if(lpPrgressCallback) lpPrgressCallback(0,0,0);

    switch(dep) {
    case 24:
        outputHeader(fp,mx,my,dep);
        encode(fp,img,mx,my);
        break;
    default:
        MessageBox(NULL,"Not support!","ERR",MB_OK);
        return 1;
    }
    if(lpPrgressCallback) lpPrgressCallback(my,my,0);
    fclose(fp);
    return 0;
}

/* 將4位元組的數值資料輸出到檔案 */
int fputLong(long num,FILE *fp)
{
    fputc((num>>24) & 0xff,fp);
    fputc((num>>16) & 0xff,fp);
    fputc((num>>8)  & 0xff,fp);
    fputc((num)     & 0xff,fp);
    return 0;
}

/* 將2位元組的數值資料輸出到檔案 */
int fputShort(signed short num,FILE *fp)
{
    fputc((num>>8)  & 0xff,fp);
    fputc((num)     & 0xff,fp);
    return 0;
}

/* 輸出標頭 */
int outputHeader(FILE *fp,int mx,int my,int dep)
{
    fputc('H',fp);
    fputc('D',fp);
    fputc('T',fp);
    fputc('2',fp);
    fputLong(mx,fp);
    fputLong(my,fp);
    return 0;
}

static int bits=0;
static int bdata=0;

/* 輸出處理的初始化 */
int fputBitInit()
{
    bits=0;
    bdata=0;
    return 0;
}

/* 輸出1位元 */
int fputBit(int bit,FILE *fp)
{
    bdata=(bdata<<1)|bit;
    bits++;
    if(bits>=8) {
        fputc(bdata,fp);
        bits=0;
        bdata=0;
    }
    return 0;
}

/* 輸出n位元 */
int putBits(FILE *fp,int data,int n)
{
    int i;

    for(i=n-1;i>=0;i--) {
        fputBit((data>>i)&1,fp);
    }
    return 0;
}

/* 將多餘的位元輸出 */
int flushBit(FILE *fp)
{
    int i;

    for(i=0;i<7;i++) {
        fputBit(0,fp);
    }
    return 0;
}

/* 輸出n位元 */
int fputNumber(int num,int bits,FILE *fp)
{
    if(num<0) {
        fputBit(1,fp);
        num= -num;
    }
    else {
        fputBit(0,fp);
    }
    putBits(fp,num,bits);
    return 0;
}

/* 使用任意位元輸出(含正負) */
int fputCompNumber(int num,int bits,FILE *fp)
{
    if(num<0) {
        fputBit(1,fp);
        num= -num;
    }
    else {
        fputBit(0,fp);
    }
    num=num>>(16-bits);
    putBits(fp,num,bits-1);
    return 0;
}

/* 存放RGB值用的資料結構 */
typedef struct RGB_COL{
    int r,g,b;
}RGBcolor;

/* 取得24位元DIB上的像素值 */
int getColor(int x,int y,unsigned char *data,int mx,int my,RGBcolor *col)
{
    int adr,mmx;

    mmx=(mx*3+3)/4*4;
    if(x>=mx) x=mx-1;
    if(y>=my) y=my-1;
    adr=x*3+(my-y-1)*mmx;
    col->r=data[adr+2];
    col->g=data[adr+1];
    col->b=data[adr];
    return 0;
}

short adm[NNN][NNN][NNN][NNN];

/* 壓縮處理主程式 */
int encode(FILE *fp,unsigned char *data,int mx,int my)
{
    int x,y,u,v;
    int lx,ly,loopx,loopy;
    int r_re[NNN*NNN];
    int sum;
    RGBcolor col;
    char mbuf[256];
    int code_bits[8*8]=
    {
        16,14,12,10, 8, 6, 4, 4,
        14,12,10, 8, 6, 4, 4, 4,
        12,10, 8, 6, 4, 4, 4, 4,
        10, 8, 6, 4, 4, 4, 4, 4,
         8, 6, 4, 4, 4, 4, 4, 4,
         6, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4,
         4, 4, 4, 4, 4, 4, 4, 4
    };

    /* 製作哈達瑪陣列 */
    for(v=0;v<NNN;v++) {
        for(u=0;u<NNN;u++) {
            for(y=0;y<NNN;y++) {
                for(x=0;x<NNN;x++) {
                    adm[u][v][x][y]=get_matrix(u,v,x,y);
                }
            }
        }
    }
    loopx=(mx+NNN-1)/NNN;
    loopy=(my+NNN-1)/NNN;
    fputBitInit();
    for(ly=0;ly<loopy;ly++) {
        for(lx=0;lx<loopx;lx++) {
            /* 製作緩衝區 */
            for(y=0;y<=NNN;y++) {
                for(x=0;x<=NNN;x++) {
                    getColor(lx*NNN+x,ly*NNN+y,data,mx,my,&col);
                    r_re[x+y*NNN]=col.r;
                }
            }

            for(v=0;v<NNN;v++) {
                for(u=0;u<NNN;u++) {
                    sum=0;
                    for(y=0;y<NNN;y++) {
                        for(x=0;x<NNN;x++) {
                            if(adm[u][v][x][y]>0) {
                                sum+=(r_re[x+y*NNN]);
                            }
                            else {
                                sum-=(r_re[x+y*NNN]);
                            }
                        }
                    }
                    fputCompNumber(sum,code_bits[v*8+u],fp);
                }
            }
        }
    }
    sprintf(mbuf,"%d %d %d %d",mx,my,loopx,loopy);
    flushBit(fp);
    return 0;
}

/* 求出哈達瑪陣列 */
int get_matrix(int u,int v,int x,int y)
{
    return (func_q(x,y,u,v)%2==0) ? 1 : -1;
}

/* 求出Fig.4-29的q */
int func_q(int x,int y,int u,int v)
{
    int i;
    int sum;

    sum=0;
    for(i=0;i<NNN;i++) {
        sum+=(getNbit(x,i)*ggg(u,i)+getNbit(y,i)*ggg(v,i));
    }
    return sum;
}

/* 求出Fig.4-29的g */
int ggg(int u,int i)
{
    return getNbit(u,Nketa-i) + getNbit(u,Nketa-i-1);
}

/* 求出x的第n位元 */
int getNbit(int x,int n)
{
    x>>=n;
    return x&1;
}
