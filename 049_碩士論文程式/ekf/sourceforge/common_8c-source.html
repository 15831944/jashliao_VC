<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DSACSS Operational Code: common.c Source File</title>
<link href="doxygen.css" tppabs="http://dsacss.sourceforge.net/doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<h1>common.c</h1><a href="common_8c.html" tppabs="http://dsacss.sourceforge.net/common_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="preprocessor">#include "<a class="code" href="satctl_8h.html" tppabs="http://dsacss.sourceforge.net/satctl_8h.html">satctl.h</a>"</span>
00002 <span class="preprocessor">#include "<a class="code" href="common_8h.html" tppabs="http://dsacss.sourceforge.net/common_8h.html">common.h</a>"</span>
00003 
00004 
00005 
<a name="l00006"></a><a class="code" href="common_8c.html#a0" tppabs="http://dsacss.sourceforge.net/common_8c.html#a0">00006</a> <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a0" tppabs="http://dsacss.sourceforge.net/common_8c.html#a0">init_serial</a>(<span class="keywordtype">char</span> *portfn, speed_t brate, <span class="keywordtype">int</span> *portfd) {
00007   <span class="keyword">struct </span>termios tty;           <span class="comment">/* tty termios attrib structure */</span>
00008   <span class="keywordtype">int</span> mcs;                      <span class="comment">/* Modem-control settings flags */</span>
00009 
00010   portfd[0] = open(portfn, O_RDWR);             <span class="comment">/* Open the port*/</span>
00011   <span class="keywordflow">if</span> (portfd[0] == -1) <span class="keywordflow">return</span>(-1);
00012 
00013   tcgetattr(portfd[0], &amp;tty);                   <span class="comment">/* Get the port attributes */</span>
00014   cfsetospeed(&amp;tty, brate);                     <span class="comment">/* Put outrate in tty struct */</span>
00015   cfsetispeed(&amp;tty, brate);                     <span class="comment">/* Put inrate in tty struct */</span>
00016 <span class="comment">/* This was an oversight.  The presumption was that we'd always be talking</span>
00017 <span class="comment"> * exclusively to devices in 8N1.  Now, to use 2 stop bits, we had to use</span>
00018 <span class="comment"> * a define to avoid rewriting all the code that uses init_serial as it is</span>
00019 <span class="comment"> * already written.  Any major version change should incorporate an option</span>
00020 <span class="comment"> * for doing this properly in the code.</span>
00021 <span class="comment"> */</span>
00022 <span class="preprocessor">#ifndef TSB</span>
00023 <span class="preprocessor"></span>  tty.c_cflag = (tty.c_cflag &amp; ~CSIZE) | CS8;   <span class="comment">/* Set 8 data bits */</span>
00024 <span class="preprocessor">#else</span>
00025 <span class="preprocessor"></span>  tty.c_cflag = (tty.c_cflag &amp; ~CSIZE) | CS8 | CSTOPB;
00026                                         <span class="comment">/* Set 8 data bits &amp; 2 stop bits */</span>
00027 <span class="preprocessor">#endif</span>
00028 <span class="preprocessor"></span>
00029   <span class="comment">/* Set raw, no echo mode */</span>
00030   tty.c_iflag = IGNBRK;                 <span class="comment">/* Set ingore-breaks */</span>
00031   tty.c_lflag = 0;                      <span class="comment">/* Clear local modes flag */</span>
00032   tty.c_oflag = 0;                      <span class="comment">/* Clear output modes flag */</span>
00033   tty.c_cflag |= CLOCAL | CREAD;        <span class="comment">/* Ignore modem ctrl/ enable rcvr */</span>
00034   tcsetattr(portfd[0], TCSANOW, &amp;tty);  <span class="comment">/* Effect flags, active now */</span>
00035 
00036   <span class="comment">/* Set RTS line */</span>
00037   ioctl(portfd[0], TIOCMGET, &amp;mcs);     <span class="comment">/* Get modem-control flags */</span>
00038   mcs |= TIOCM_RTS | TIOCM_DTR;         <span class="comment">/* Modify modem-control flags */</span>
00039   ioctl(portfd[0], TIOCMSET, &amp;mcs);     <span class="comment">/* Put modem-control flags */</span>
00040 
00041   <span class="comment">/* Port is ready for use */</span>
00042   <span class="keywordflow">return</span>(0);
00043 }
00044 
<a name="l00045"></a><a class="code" href="common_8c.html#a1" tppabs="http://dsacss.sourceforge.net/common_8c.html#a1">00045</a> <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a1" tppabs="http://dsacss.sourceforge.net/common_8c.html#a1">say</a>(<span class="keywordtype">int</span> fd, <span class="keywordtype">char</span> *str) {
00046   <span class="keyword">static</span> <span class="keywordtype">int</span> wrote;                     <span class="comment">/* Number of bytes written */</span>
00047   <span class="keyword">static</span> <span class="keywordtype">char</span> eol[2] = {<span class="charliteral">'\r'</span>, 12};      <span class="comment">/* The EOL characters */</span>
00048   <span class="keyword">static</span> <span class="keywordtype">int</span> slen;                      <span class="comment">/* Length of submitted string */</span>
00049   <span class="keywordtype">char</span> *tmp;                            <span class="comment">/* a temporary write buffer */</span>
00050 
00051   slen = strlen(str);                   <span class="comment">/* Get # bytes to write */</span>
00052   <span class="comment">/*if (debug&gt;4)</span>
00053 <span class="comment">    fprintf(stderr, "writing \"%s\" (len: %d) to %d\n", str, slen+2, fd);*/</span>
00054   
00055   <span class="comment">/*tmp = (char *)malloc(slen+3);               /* Allocate buffer accordingly */</span>
00056   <span class="comment">/*strcpy(tmp, str);                   /* Copy and add 2 EOL's &amp; a NULL */</span>
00057   <span class="comment">/*tmp[slen++] = eol[0];</span>
00058 <span class="comment">  tmp[slen++] = eol[0];</span>
00059 <span class="comment">  tmp[slen] = 0;</span>
00060 <span class="comment">  */</span>
00061  
00062   wrote = write(fd, str, slen);         <span class="comment">/* Hocus Pocus !!! */</span>
00063   <span class="comment">/* TODO: Here's the first thing that could stand fixing.  This writing</span>
00064 <span class="comment">   * is all but blind.  Granted, we return what we wrote, but we don't</span>
00065 <span class="comment">   * loop to write the rest.  At this point, writing commands on the order</span>
00066 <span class="comment">   * of 10 bytes max, this should suffice.  Later on, this routine will</span>
00067 <span class="comment">   * probably need to be made more robust.</span>
00068 <span class="comment">   */</span>
00069   <span class="keywordflow">if</span> (!wrote) perror(<span class="stringliteral">"say():write() failed"</span>);
00070  <span class="comment">/* if (debug&gt;4)</span>
00071 <span class="comment">    fprintf(stderr, "wrote %d bytes\n", wrote);</span>
00072 <span class="comment">  free(tmp);*/</span>
00073   <span class="keywordflow">return</span>(0);
00074 }
00075 
<a name="l00076"></a><a class="code" href="common_8c.html#a2" tppabs="http://dsacss.sourceforge.net/common_8c.html#a2">00076</a> <span class="keywordtype">int</span> <a class="code" href="common_8c.html#a2" tppabs="http://dsacss.sourceforge.net/common_8c.html#a2">hear</a>(<span class="keywordtype">int</span> fd, <span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> maxlen, <span class="keywordtype">int</span> minlen, <span class="keywordtype">int</span> maxbtime, <span class="keywordtype">char</span> term) {
00077   <span class="keywordtype">int</span> tbr = 0,                  <span class="comment">/* Total bytes read (cumulative) */</span>
00078   br,                           <span class="comment">/* Bytes read (in a single read) */</span>
00079   i,                            <span class="comment">/* A loop variable */</span>
00080   newread;                      <span class="comment">/* Local read counter */</span>
00081   <span class="keyword">struct </span>timeval rtmr;          <span class="comment">/* Time to block in select() call */</span>
00082   fd_set rfds;                  <span class="comment">/* fd set containing our port fd */</span>
00083   <span class="keywordtype">char</span> *ptr;
00084   <span class="keyword">static</span> <span class="keywordtype">char</span> *left = NULL;
00085   <span class="keyword">static</span> <span class="keywordtype">int</span> useleft = 0;
00086 
00087   <span class="keywordflow">if</span> (!left)
00088           left = (<span class="keywordtype">char</span> *)malloc(maxlen+1);
00089   bzero(str, maxlen);           <span class="comment">/* Zero out the target string (&amp; illicit</span>
00090 <span class="comment">                                 * any segfaults now in case someone didn't</span>
00091 <span class="comment">                                 * properly initialize this.  Sneaky, eh?) */</span>
00092   FD_ZERO(&amp;rfds);               <span class="comment">/* Setup the fd set */</span> 
00093   FD_SET(fd, &amp;rfds);
00094 
00095   rtmr.tv_sec = maxbtime/1000000;  <span class="comment">/* Setup the block timer */</span>
00096   rtmr.tv_usec = maxbtime - (rtmr.tv_sec * 1000000);
00097   <span class="comment">/* First, check for leftovers from last time... */</span>
00098   <span class="keywordflow">if</span> (useleft) {
00099           strcpy(str, left);
00100           tbr = strlen(left);
00101           left[0] = 0;
00102   }
00103   <span class="comment">/* This is not too straightforward, but should be sufficiently sophisticated.</span>
00104 <span class="comment">   * Regardless, it's complicated enough to warrant explanation.</span>
00105 <span class="comment">   * This loop will run the shortest of:</span>
00106 <span class="comment">   * 1) 2 un-reset loops (2 loops of maxbtime usec w/o read data)</span>
00107 <span class="comment">   * 2) IF minlen, then until tbr &gt;= minlen (i.e. minlen bytes get read)</span>
00108 <span class="comment">   * 3) IF NOT minlen, then until tbr[last]=term (i.e. the term char gets read)</span>
00109 <span class="comment">   * 4) maxlen characters already read</span>
00110 <span class="comment">   */</span>
00111   <span class="keywordflow">for</span> ( i = 0;
00112         <span class="comment">/* Run while i &lt; 3 (until i reaches 3) and.... */</span>
00113         (i &lt; 3) &amp;&amp;
00114         <span class="comment">/* If minlen, then while tbr &lt; minlen, else until we get a term char */</span>
00115         <span class="comment">/*(minlen ? (tbr&lt;minlen) : (str[tbr?(tbr-1):0]!=term) ) &amp;&amp;*/</span>
00116         (minlen ? (tbr&lt;minlen) : !strchr(str, term)) &amp;&amp;
00117         (maxlen &gt; tbr) ;
00118         i++) {
00119     <span class="keywordflow">if</span> (select(fd+1, &amp;rfds, NULL, NULL, &amp;rtmr)) {    <span class="comment">/* Data to read? */</span>
00120       tbr = read(fd, str+tbr, maxlen-tbr);          <span class="comment">/* Read returned data */</span>
00121       i = 0;
00122     } <span class="keywordflow">else</span> {
00123       <span class="comment">/*printf("hear(): select() failed %d'th time.\n", i);*/</span>
00124     }
00125   } 
00126   <span class="keywordflow">if</span> (!minlen)
00127           <span class="keywordflow">if</span> (ptr=strchr(str, term)) {          <span class="comment">/* Assignment intentional */</span>
00128                   <span class="keywordflow">if</span> (ptr != str+tbr-1) {       <span class="comment">/* The term character is being used, but is NOT the last character read */</span>
00129                           strcpy(left, ptr+1);  <span class="comment">/* So copy the rest into the leftover buffer */</span>
00130                           useleft = 1;          <span class="comment">/* Mark the marker. */</span>
00131                           tbr -= (<span class="keywordtype">int</span>)((str+tbr)-ptr);  <span class="comment">/* and reduce tbr to the right value */</span>
00132                           ptr[1] = 0;           <span class="comment">/* Finally, terminate the return string at the right place */</span>
00133                   }
00134           }
00135   <span class="keywordflow">if</span> (tbr == 0) {
00136     <span class="comment">/*if (debug &gt; 3) errlog("hear(): 0 bytes read\n");*/</span>
00137     <span class="keywordflow">return</span>(1);
00138   }
00139   <span class="keywordflow">return</span>(0);
00140 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jun 15 11:49:53 2004 for DSACSS Operational Code by
<a href="javascript:if(confirm('http://www.doxygen.org/index.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.doxygen.org/index.html'" tppabs="http://www.doxygen.org/index.html">
<img src="doxygen.png" tppabs="http://dsacss.sourceforge.net/doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.4 </small></address>
</body>
</html>
