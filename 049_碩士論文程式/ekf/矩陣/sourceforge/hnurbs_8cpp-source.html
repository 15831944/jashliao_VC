<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>hnurbs.cpp Source File</title>
<link href="doxygen.css" tppabs="http://libnurbs.sourceforge.net/docs/doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.14 -->
<center>
<a class="qindex" href="index.html" tppabs="http://libnurbs.sourceforge.net/docs/index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html" tppabs="http://libnurbs.sourceforge.net/docs/hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html" tppabs="http://libnurbs.sourceforge.net/docs/annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html" tppabs="http://libnurbs.sourceforge.net/docs/files.html">File List</a> &nbsp; <a class="qindex" href="functions.html" tppabs="http://libnurbs.sourceforge.net/docs/functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>hnurbs.cpp</h1><div class="fragment"><pre>00001 <font class="comment">/*=============================================================================</font>
00002 <font class="comment">        File: hnurbs.cpp</font>
00003 <font class="comment">     Purpose:       </font>
00004 <font class="comment">    Revision: $Id: hnurbs.cpp,v 1.3 2003/01/13 19:41:27 philosophil Exp $</font>
00005 <font class="comment">  Created by: Philippe Lavoie          (3 Oct, 1996)</font>
00006 <font class="comment"> Modified by: </font>
00007 <font class="comment"></font>
00008 <font class="comment"> Copyright notice:</font>
00009 <font class="comment">          Copyright (C) 1996-1997 Philippe Lavoie</font>
00010 <font class="comment"> </font>
00011 <font class="comment">          This library is free software; you can redistribute it and/or</font>
00012 <font class="comment">          modify it under the terms of the GNU Library General Public</font>
00013 <font class="comment">          License as published by the Free Software Foundation; either</font>
00014 <font class="comment">          version 2 of the License, or (at your option) any later version.</font>
00015 <font class="comment"> </font>
00016 <font class="comment">          This library is distributed in the hope that it will be useful,</font>
00017 <font class="comment">          but WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00018 <font class="comment">          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
00019 <font class="comment">          Library General Public License for more details.</font>
00020 <font class="comment"> </font>
00021 <font class="comment">          You should have received a copy of the GNU Library General Public</font>
00022 <font class="comment">          License along with this library; if not, write to the Free</font>
00023 <font class="comment">          Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</font>
00024 <font class="comment">=============================================================================*/</font>
00025 
00026 <font class="preprocessor">#ifndef PLIB_NURBS_HNURBS_SOURCE</font>
00027 <font class="preprocessor"></font><font class="preprocessor">#define PLIB_NURBS_HNURBS_SOURCE</font>
00028 <font class="preprocessor"></font>
00029 <font class="preprocessor">#include &lt;hnurbs.h&gt;</font>
00030 
00031 HNurbsCurveNode::HNurbsCurveNode():u0(u0_),u1(u1_){
00032   prev = 0 ;
00033   next = 0 ;
00034   curve = <font class="keyword">new</font> NurbsCurve ;
00035   u0 = 0 ;
00036   u1 = 1 ;
00037   uD = 1 ;
00038 }
00039 
00040 HNurbsCurveNode::HNurbsCurveNode(<font class="keyword">const</font> NurbsCurve &amp;c, T uS, T uE):u0(u0_),u1(u1_){
00041   prev = 0 ;
00042   next = 0 ;
00043   curve = <font class="keyword">new</font> NurbsCurve(c) ;
00044   u0 = uS ;
00045   u1 = uE ;
00046   uD = uE-uS ;
00047 }
00048 
00049 HPoint_nD&lt;T,N&gt; HNurbsCurveNode::operator()(T u)<font class="keyword"> const </font>{
00050   <font class="keywordflow">if</font>(u&lt;u0 || u&gt;u1)
00051     <font class="keywordflow">return</font> HPoint_nD&lt;T,N&gt;(0,0,0,0) ;
00052   
00053   u -= u0_ ;
00054   u /= uD ;
00055   <font class="keywordflow">return</font> (*curve)(u) ;
00056 }
00057 
00058 <font class="keywordtype">void</font> HNurbsCurveNode::deriveAt(T u, <font class="keywordtype">int</font> d, Vector&lt; Point_nD&lt;T,N&gt; &gt;&amp; ders)<font class="keyword"> const </font>{
00059   ders.resize(d+1) ;
00060   ders.reset(0) ;
00061   <font class="keywordflow">if</font>(u&lt;u0 || u&gt;u1)
00062     <font class="keywordflow">return</font> ;
00063   
00064   u -= u0_ ;
00065   u /= uD ;
00066   curve-&gt;deriveAt(u,d,ders) ;
00067 }
00068 
00069 <font class="keywordtype">void</font> HNurbsCurveNode::deriveAt(T u, <font class="keywordtype">int</font> d, Vector&lt; HPoint_nD&lt;T,N&gt; &gt;&amp; ders)<font class="keyword"> const </font>{
00070   ders.resize(d+1) ;
00071   ders.reset(0) ;
00072   <font class="keywordflow">if</font>(u&lt;u0 || u&gt;u1)
00073     <font class="keywordflow">return</font> ;
00074   
00075   u -= u0_ ;
00076   u /= uD ;
00077   curve-&gt;deriveAt(u,d,ders) ;
00078 }
00079 
00080 
00081 HNurbsCurve::HNurbsCurve(){
00082   first = 0 ;
00083   last = 0 ;
00084 }
00085 
00086 <font class="keywordtype">void</font> HNurbsCurve::add(<font class="keyword">const</font> NurbsCurve&amp; curve, T uS, T uE) {
00087   HNurbsCurveNode *nC ;
00088   nC = <font class="keyword">new</font> HNurbsCurveNode(curve,uS,uE) ;
00089   nC-&gt;prev = last ;
00090   <font class="keywordflow">if</font>(last)
00091     last-&gt;next = nC ;
00092   <font class="keywordflow">if</font>(!first)
00093     first = nC ;
00094   last = nC ;
00095 }
00096 
00097 <font class="keywordtype">void</font> HNurbsCurve::remove(<font class="keywordtype">void</font>){
00098   HNurbsCurveNode *tC ;
00099   <font class="keywordflow">if</font>(last){
00100     tC = last ;
00101     last = last-&gt;prev;
00102     last-&gt;next = 0 ;
00103     <font class="keyword">delete</font> tC ;
00104   }
00105 }
00106 
00107 HPoint_nD&lt;T,N&gt; HNurbsCurve::operator()(T u)<font class="keyword"> const</font>{
00108   HNurbsCurveNode *c ;
00109   HPoint_nD&lt;T,N&gt; result(0,0,0,0) ;
00110   HPoint_nD&lt;T,N&gt; temp ;
00111   Point_nD&lt;T,N&gt; temp2 ;
00112   c = first ;
00113   <font class="keywordflow">while</font>(c){
00114     temp = (*c)(u) ;
00115     <font class="keywordflow">if</font>(temp.w()!= 0){
00116       temp2 = project(temp) ;
00117       result.x() += temp2.x() ; 
00118       result.y() += temp2.y() ; 
00119       result.z() += temp2.z() ; 
00120     }
00121     c = c-&gt;next ;
00122   }
00123   result.w() = 1.0 ;
00124   <font class="keywordflow">return</font> result ;
00125 }
00126 
00127 <font class="keywordtype">void</font> HNurbsCurve::deriveAt(T u,<font class="keywordtype">int</font> d, Vector&lt; HPoint_nD&lt;T,N&gt; &gt;&amp; ders)<font class="keyword"> const</font>{
00128   HNurbsCurveNode *c ;
00129   Vector&lt; HPoint_nD&lt;T,N&gt; &gt; dTemp(d+1) ;
00130 
00131   ders.resize(d+1) ;
00132   ders.reset(0) ;
00133   c = first ;
00134   <font class="keywordflow">while</font>(c){
00135     c-&gt;deriveAt(u,d,dTemp) ;
00136     ders += dTemp ;
00137     c = c-&gt;next ;
00138   }
00139 }
00140 <font class="keywordtype">void</font> HNurbsCurve::deriveAt(T u,<font class="keywordtype">int</font> d, Vector&lt; Point_nD&lt;T,N&gt; &gt;&amp; ders)<font class="keyword"> const</font>{
00141   HNurbsCurveNode *c ;
00142   Vector&lt; Point_nD&lt;T,N&gt; &gt; dTemp(d+1) ;
00143 
00144   ders.resize(d+1) ;
00145   ders.reset(0) ;
00146   c = first ;
00147   <font class="keywordflow">while</font>(c){
00148     c-&gt;deriveAt(u,d,dTemp) ;
00149     ders += dTemp ;
00150     c = c-&gt;next ;
00151   }
00152 }
00153 
00154 
00155 
00156 <font class="keywordtype">void</font> HNurbsCurve::draw(<a class="code" href="classPLib_1_1MatrixImage.html" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1MatrixImage.html">Image_Color</a>&amp; img, <font class="keyword">const</font> Color&amp; col)<font class="keyword"> const </font>{
00157   <font class="keyword">const</font> <font class="keywordtype">int</font> n=100 ;
00158   T dU = 1.0/T(n) ;
00159   T uP = 0 ;
00160   HPoint_nD&lt;T,N&gt; p,c ;
00161   Point_nD&lt;T,N&gt; p3,c3 ;
00162   
00163   p = point4D(uP) ;
00164   <font class="keywordflow">for</font>(T u=dU; u&lt;1.0; u += dU){
00165     c = point4D(u) ;
00166     p3 = project(p) ;
00167     c3 = project(c) ;
00168     img.<a class="code" href="classPLib_1_1MatrixImage.html#a5" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1MatrixImage.html#a5">drawLine</a>((<font class="keywordtype">int</font>)p3.y(),(int)p3.x(),(int)c3.y(),(int)c3.x(),col) ;
00169     p = c ;
00170   }
00171   c = point4D(1.0) ;
00172   p3 = project(p) ;
00173   c3 = project(c) ;
00174   img.<a class="code" href="classPLib_1_1MatrixImage.html#a5" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1MatrixImage.html#a5">drawLine</a>((<font class="keywordtype">int</font>)p3.y(),(int)p3.x(),(int)c3.y(),(int)c3.x(),col) ;
00175 }
00176 
00177 <font class="keywordtype">void</font> HNurbsCurve::draw(<a class="code" href="classPLib_1_1MatrixImage.html" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1MatrixImage.html">Image_UBYTE</a> &amp;img, <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font> col)<font class="keyword"> const </font>{
00178   <font class="keyword">const</font> <font class="keywordtype">int</font> n=100 ;
00179   T dU = 1.0/T(n) ;
00180   HPoint_nD&lt;T,N&gt; p,c ;
00181   Point_nD&lt;T,N&gt; p3,c3 ;
00182 
00183   p3 = point3D(0.0) ;
00184   <font class="keywordflow">for</font>(T u=dU;u&lt;1.0;u+=dU){
00185     c3 = point3D(u) ;
00186     img.<a class="code" href="classPLib_1_1MatrixImage.html#a5" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1MatrixImage.html#a5">drawLine</a>((<font class="keywordtype">int</font>)p3.y(),(int)p3.x(),(int)c3.y(),(int)c3.x(),col) ;
00187     p3 = c3 ;
00188   }
00189   c3 = point3D(1.0);
00190   img.<a class="code" href="classPLib_1_1MatrixImage.html#a5" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1MatrixImage.html#a5">drawLine</a>((<font class="keywordtype">int</font>)p3.y(),(int)p3.x(),(int)c3.y(),(int)c3.x(),col) ;
00191 }
00192 
00193 <font class="keyword">const</font> <font class="keywordtype">int</font> MaxRandom = 32768 ; <font class="comment">// 2^15</font>
00194 
00195 
00196 <font class="keywordtype">void</font> HNurbsCurve::reset(){
00197   HNurbsCurveNode* t ;
00198   <font class="keywordflow">while</font>(last){
00199     t = last-&gt;prev ;
00200     <font class="keywordflow">if</font>(last-&gt;curve)
00201       <font class="keyword">delete</font> last-&gt;curve ;
00202     <font class="keyword">delete</font> last ;
00203     last = t ;
00204   } 
00205 }
00206 
00207 
00208 <font class="comment">// needs to be tested, and checked if this actually optimizes the method used in interpolate</font>
00209 <font class="keywordtype">void</font> setRandomVector(<a class="code" href="classPLib_1_1Vector.html" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1Vector.html">Vector_INT</a>&amp; rV, <font class="keywordtype">int</font> rangeSize, <font class="keywordtype">int</font> rangeOffset, <font class="keywordtype">int</font> startAt=0, <font class="keywordtype">int</font>  finishAt=-1){
00210   <font class="keywordflow">if</font>(finishAt&lt;0)
00211     finishAt= rV.<a class="code" href="classPLib_1_1BasicArray.html#a0" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1BasicArray.html#a0">n</a>-1 ;
00212   <font class="keywordflow">if</font>(rV.<a class="code" href="classPLib_1_1BasicArray.html#a0" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1BasicArray.html#a0">n</a>&lt;=finishAt){
00213     cerr &lt;&lt; <font class="stringliteral">"You need to set the random vector's size to the proper value PRIOR to calling this function!\n"</font> ;
00214     <font class="keywordflow">while</font>(1){;}
00215   }
00216   
00217   <font class="comment">// write from 0 and offset it afterwards...</font>
00218   <font class="keywordtype">int</font> i ;
00219   <font class="keywordflow">for</font>(i=startAt;i&lt;=finishAt;++i){
00220     <font class="keywordtype">double</font> r = double(rand()) ;
00221     <font class="keywordtype">int</font> l ;
00222     r /= double(MaxRandom) ; <font class="comment">// r = [0,1] </font>
00223     r *= double(rangeSize) ; <font class="comment">// r=[0,rangeSize] ;</font>
00224     --rangeSize ;
00225     l = int(r) ;
00226     <font class="keywordflow">for</font>(<font class="keywordtype">int</font> j=startAt;j&lt;i;++j){
00227       <font class="keywordflow">if</font>(rV[j]&lt;=l){
00228         ++l ;
00229       }
00230       <font class="keywordflow">else</font>{
00231         <font class="keywordtype">int</font> k=j ;
00232         <font class="keywordflow">for</font>(j=i;j&gt;k;--j){
00233           rV[j] = rV[j-1] ;
00234         }
00235         rV[k] = l ;
00236         <font class="keywordflow">break</font> ;
00237       }
00238     }
00239   }
00240 
00241   <font class="keywordflow">for</font>(i=0;i&lt;=finishAt-startAt;i++)
00242     rV[i] += rangeOffset ;
00243 }
00244 
00245 <font class="keywordtype">void</font> HNurbsCurve::interpolate(<font class="keyword">const</font> Vector&lt; Point_nD&lt;T,N&gt; &gt; &amp;Pts, <font class="keywordtype">int</font> deg, T acceptError, <font class="keywordtype">int</font> nSample, <font class="keywordtype">int</font> maxTries, <font class="keywordtype">int</font> nInitPoints, <font class="keywordtype">int</font> nPoints){
00246   <font class="comment">// Get a first interpolation of the data points</font>
00247   <font class="keywordflow">if</font>(nInitPoints&lt;0) nInitPoints = deg*2 ;
00248   <font class="keywordflow">if</font>(nPoints&lt;0) nPoints = deg*2 ;
00249 
00250   <font class="keywordflow">if</font>(nPoints&lt;deg+1 || nInitPoints &lt; deg+1){
00251     cerr &lt;&lt; <font class="stringliteral">"Using a number of points smaller than deg+1!\n"</font> ;
00252     <font class="keywordflow">while</font>(1){;}
00253   }
00254   <font class="keywordflow">if</font>(Pts.n&lt;deg+1){
00255     cerr &lt;&lt; <font class="stringliteral">"Not enough points to interpolate !\n"</font> ;
00256     <font class="keywordflow">while</font>(1){;} 
00257   }
00258 
00259   <font class="keywordtype">int</font> i,j,k ;
00260   
00261   NurbsCurve sampleC,minC ;
00262   Vector&lt; Point_nD&lt;T,N&gt; &gt; sampleP ;
00263   <a class="code" href="classPLib_1_1Vector.html" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1Vector.html">Vector_INT</a> sampleI ;
00264   Vector&lt;T&gt; error ;
00265   T minError = -1.0 ;
00266 
00267   sampleP.<a class="code" href="classPLib_1_1BasicArray.html#a9" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1BasicArray.html#a9">resize</a>(nInitPoints) ;
00268   sampleI.<a class="code" href="classPLib_1_1BasicArray.html#a9" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1BasicArray.html#a9">resize</a>(nInitPoints) ;
00269   error.resize(Pts.n) ;
00270   srand(123) ;
00271 
00272   <font class="keywordflow">for</font>(k=0;k&lt;nSample;++k){
00273     sampleI[0] = 0 ;
00274     sampleI[sampleP.<a class="code" href="classPLib_1_1BasicArray.html#a0" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1BasicArray.html#a0">n</a>-1] = Pts.n-1 ;
00275     <font class="keywordflow">for</font>(i=1;i&lt;sampleP.n-1;++i){
00276       <font class="keywordtype">int</font> ok = 0 ;
00277       <font class="keywordflow">while</font>(!ok){
00278         ok = 1 ;
00279         <font class="keywordtype">double</font> r = double(rand()) ;
00280         r /= double(MaxRandom) ; <font class="comment">// r = [0,1] </font>
00281         r *= Pts.n-2 ; <font class="comment">// r=[0,Pts.n-2] ;</font>
00282         r += 1 ; <font class="comment">// r=[1,Pts.n-1]</font>
00283         sampleI[i] = int(r) ;
00284         <font class="keywordflow">for</font>(j=0;j&lt;i;++j){
00285           <font class="keywordflow">if</font>(sampleI[j] == sampleI[i]){
00286             ok = 0 ;
00287             <font class="keywordflow">break</font> ;
00288           }
00289         }
00290       }
00291     }
00292     sampleI.<a class="code" href="classPLib_1_1Vector.html#a18" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1Vector.html#a18">qSort</a>() ;
00293     <font class="keywordflow">for</font>(i=0;i&lt;sampleP.n;++i)
00294       sampleP[i] = Pts[sampleI[i]] ;
00295     sampleC.globalInterp(sampleP,deg) ;
00296     T u = 0 ;
00297     <font class="keywordflow">for</font>(i=0;i&lt;Pts.n;++i){
00298       T e = sampleC.minDist2(Pts[i],u) ;
00299       error[i] = e ;
00300     }
00301     error.qSort() ;
00302     <font class="keywordflow">if</font>(minError&gt;error[error.n/2] || minError&lt;0){
00303       minError = error[error.n/2] ;
00304       minC = sampleC ;
00305     }
00306   }
00307   reset() ;
00308   add(minC,0,1) ;
00309   
00310   <font class="comment">//  cerr &lt;&lt; "Done first interpolation = " &lt;&lt; minError &lt;&lt; endl ;</font>
00311   
00312   <font class="comment">// Finding the maximal error region and modifying the HNURBS until there is no more errors...</font>
00313   T maxError ; 
00314   <a class="code" href="classPLib_1_1Vector.html" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1Vector.html">Vector_INT</a> regionI(Pts.n) ;
00315   Vector&lt;T&gt; regionU(Pts.n) ;
00316   sampleP.resize(nPoints) ;
00317   sampleI.<a class="code" href="classPLib_1_1BasicArray.html#a9" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1BasicArray.html#a9">resize</a>(nPoints) ;
00318   Vector&lt;T&gt; errorM,errorT ;
00319   <font class="keywordtype">int</font> tryN = 0; 
00320   <font class="keywordflow">while</font>(tryN &lt; maxTries){
00321     <font class="comment">// Find max error between regions with no errors</font>
00322     T minU,maxU,tempError,u ; 
00323     <font class="keywordtype">int</font> maxI = 0 ;
00324 
00325     <font class="keywordtype">int</font> index = 0 ;
00326     regionI[0] = 0 ;
00327     regionU[0] = 0.0 ;
00328     maxError = -1.0 ;
00329     u = 0 ;
00330     
00331     <font class="keywordflow">for</font>(i=1;i&lt;Pts.n-1;++i){ <font class="comment">// the end points have always an error of 0</font>
00332       tempError = minDist2(Pts[i],u) ;
00333       <font class="keywordflow">if</font>(tempError&lt;acceptError){
00334         ++index ;
00335         regionI[index] = i ;
00336         regionU[index] = u ;
00337         <font class="keywordflow">continue</font> ;
00338       }
00339       <font class="keywordflow">if</font>(tempError&gt;maxError){
00340         maxError = tempError ;
00341         maxI = index ;  <font class="comment">// The error is located between region maxI and maxI+1</font>
00342       }
00343     }
00344     ++index ;
00345     regionI[index] = Pts.<a class="code" href="classPLib_1_1BasicArray.html#a0" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1BasicArray.html#a0">n</a>-1 ;
00346     regionU[index] = 1.0 ;
00347     ++index ;
00348     <font class="keywordflow">if</font>(maxError&lt;acceptError){
00349       tryN = maxTries ;
00350       <font class="keywordflow">break</font> ;
00351     }
00352     
00353     <font class="comment">// for the max region we add a curve fit</font>
00354     <font class="comment">// 1st) find a region of sufficient size</font>
00355     <font class="keywordtype">int</font> regionS = maxI ;
00356     <font class="keywordtype">int</font> regionE = maxI+1 ;
00357     
00358     <font class="keywordflow">while</font>((regionI[regionE]-regionI[regionS]) &lt; 2*nPoints){ <font class="comment">// must use a bigger region</font>
00359       <font class="keywordflow">if</font>(regionS&gt;0) --regionS ;
00360       <font class="keywordflow">if</font>(regionE&lt;index-1) ++regionE ;      
00361     }
00362     
00363     <font class="keywordtype">int</font> regionSize = regionI[regionE]-regionI[regionS] ;
00364     <font class="keywordtype">int</font> regionStart = regionI[regionS] ;
00365     
00366     error.<a class="code" href="classPLib_1_1BasicArray.html#a9" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1BasicArray.html#a9">resize</a>(regionSize) ;
00367     errorM.resize(regionSize) ;
00368 
00369     minError = -1.0 ;
00370     <font class="keywordflow">for</font>(k=0;k&lt;nSample;++k){
00371       sampleI[0] = regionStart ;
00372       sampleI[sampleP.<a class="code" href="classPLib_1_1BasicArray.html#a0" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1BasicArray.html#a0">n</a>-1] = regionI[regionE] ;
00373       <font class="keywordflow">if</font>(regionSize==nPoints){
00374         k=nSample ;
00375         <font class="keywordflow">for</font>(i=1;i&lt;sampleP.n-1;++i)
00376           sampleI[i] = regionStart+i ;
00377       }
00378       <font class="keywordflow">else</font>{
00379         <font class="keywordflow">for</font>(i=1;i&lt;sampleP.n-1;++i){
00380           <font class="keywordtype">int</font> ok = 0 ;
00381           <font class="keywordflow">while</font>(!ok){
00382             ok = 1 ;
00383             <font class="keywordtype">double</font> r = double(rand()) ;
00384             r /= double(MaxRandom) ; <font class="comment">// r = [0,1] </font>
00385             r *= regionSize-2 ; <font class="comment">// r=[0,regionSize-2] ;</font>
00386             r += 1 ; <font class="comment">// r=[1,regionSize-1]</font>
00387             sampleI[i] = int(r)+regionStart ;
00388             <font class="keywordflow">for</font>(j=0;j&lt;i;++j){
00389               <font class="keywordflow">if</font>(sampleI[j] == sampleI[i]){
00390                 ok = 0 ;
00391                 <font class="keywordflow">break</font> ;
00392               }
00393             }
00394           }
00395         }
00396       }
00397       sampleI.<a class="code" href="classPLib_1_1Vector.html#a18" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1Vector.html#a18">qSort</a>() ;
00398       u = regionU[regionS] ;
00399       <font class="keywordflow">for</font>(i=1;i&lt;sampleP.n-1;++i){
00400         <font class="comment">//T closest = minDist2(Pts[sampleI[i]],u) ;</font>
00401         sampleP[i] = Pts[sampleI[i]] - point3D(u) ;
00402       }
00403       sampleP[0] = Point_nD&lt;T,N&gt;(0,0,0) ;
00404       sampleP[sampleP.n-1] = Point_nD&lt;T,N&gt;(0,0,0) ;
00405       sampleC.globalInterp(sampleP,deg) ;
00406       u = regionU[regionS] ;
00407       <font class="keywordflow">for</font>(i=0;i&lt;error.n;++i){
00408         <font class="comment">//T closestE = minDist2(Pts[regionStart+i],u) ;</font>
00409         Point_nD&lt;T,N&gt; closest = point3D(u) ;
00410         T u2 = u ;
00411         u2 -= regionU[regionS] ;
00412         u2 /= regionU[regionE]-regionU[regionS] ;
00413         <font class="keywordflow">if</font>(u2&lt;0 || u2&gt; 1.0) {
00414           cerr &lt;&lt; <font class="stringliteral">"Error in setting up u2!\n"</font> ;
00415           <font class="keywordflow">while</font>(1) {; }
00416         }
00417         error[i] = abs2(closest+project(sampleC(u2))-Pts[regionStart+i]) ;
00418       }
00419       error.qSort() ;
00420       <font class="keywordflow">if</font>(minError&gt;error[error.n/2] || minError&lt;0){
00421         minError = error[error.n/2] ;
00422         minC = sampleC ;
00423         minU = regionU[regionS] ;
00424         maxU = regionU[regionE] ;
00425         errorM = error ;
00426       }
00427     }
00428     add(minC,regionU[regionS],regionU[regionE]) ;
00429     <font class="comment">//cerr &lt;&lt; "Testing Error analysis\n" ;</font>
00430     errorT.resize(errorM.n) ;
00431     u = regionU[regionS] ;
00432     <font class="keywordflow">for</font>(i=0;i&lt;errorT.n;++i) {
00433       T closestE = minDist2(Pts[i+regionStart],u) ;
00434       errorT[i] = closestE ;
00435       <font class="comment">//cerr &lt;&lt; "error at " &lt;&lt; i &lt;&lt; " = " &lt;&lt; errorM[i] &lt;&lt; " or " &lt;&lt; errorT[i] &lt;&lt; "for point " &lt;&lt; Pts[i+regionStart] &lt;&lt; " and " &lt;&lt; point3D(u) &lt;&lt; endl ;</font>
00436     }
00437     errorT.qSort() ;
00438     
00439 
00440     <font class="comment">//    cerr &lt;&lt; "At try  " &lt;&lt; tryN &lt;&lt; " maxError = " &lt;&lt; maxError &lt;&lt; " and now it is " &lt;&lt; errorT[errorT.n-1] &lt;&lt; " for region " &lt;&lt; maxI &lt;&lt; "[ " &lt;&lt; regionStart &lt;&lt; ", " &lt;&lt; regionI[regionE] &lt;&lt; "]" &lt;&lt;  index &lt;&lt; endl ;</font>
00441     ++tryN ;
00442   }
00443 
00444 }
00445 
00446 
00447 <font class="preprocessor">#endif // #define PLIB_NURBS_HNURBS_SOURCE</font>
</pre></div><hr><address><small>Generated on Tue Jun 24 13:26:55 2003 for NURBS++ by
<a href="javascript:if(confirm('http://www.doxygen.org/index.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.doxygen.org/index.html'" tppabs="http://www.doxygen.org/index.html">
<img src="doxygen.gif" tppabs="http://libnurbs.sourceforge.net/docs/doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.14 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2002</small></address>
</body>
</html>
