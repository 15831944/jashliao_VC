<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>nurbsSub.cpp Source File</title>
<link href="doxygen.css" tppabs="http://libnurbs.sourceforge.net/docs/doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.14 -->
<center>
<a class="qindex" href="index.html" tppabs="http://libnurbs.sourceforge.net/docs/index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html" tppabs="http://libnurbs.sourceforge.net/docs/hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html" tppabs="http://libnurbs.sourceforge.net/docs/annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html" tppabs="http://libnurbs.sourceforge.net/docs/files.html">File List</a> &nbsp; <a class="qindex" href="functions.html" tppabs="http://libnurbs.sourceforge.net/docs/functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>nurbsSub.cpp</h1><div class="fragment"><pre>00001 <font class="comment">/*=============================================================================</font>
00002 <font class="comment">        File: nurbsSub.cpp</font>
00003 <font class="comment">     Purpose:       </font>
00004 <font class="comment">    Revision: $Id: nurbsSub.cpp,v 1.3 2003/01/13 19:42:10 philosophil Exp $</font>
00005 <font class="comment">  Created by: Philippe Lavoie          (20 Januray, 1999)</font>
00006 <font class="comment"> Modified by: </font>
00007 <font class="comment"></font>
00008 <font class="comment"> Copyright notice:</font>
00009 <font class="comment">          Copyright (C) 1999 Philippe Lavoie</font>
00010 <font class="comment"> </font>
00011 <font class="comment">          This library is free software; you can redistribute it and/or</font>
00012 <font class="comment">          modify it under the terms of the GNU Library General Public</font>
00013 <font class="comment">          License as published by the Free Software Foundation; either</font>
00014 <font class="comment">          version 2 of the License, or (at your option) any later version.</font>
00015 <font class="comment"> </font>
00016 <font class="comment">          This library is distributed in the hope that it will be useful,</font>
00017 <font class="comment">          but WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00018 <font class="comment">          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
00019 <font class="comment">          Library General Public License for more details.</font>
00020 <font class="comment"> </font>
00021 <font class="comment">          You should have received a copy of the GNU Library General Public</font>
00022 <font class="comment">          License along with this library; if not, write to the Free</font>
00023 <font class="comment">          Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</font>
00024 <font class="comment">=============================================================================*/</font>
00025 
00026 <font class="preprocessor">#ifndef PLIB_NURBS_NURBSSUB_SOURCE</font>
00027 <font class="preprocessor"></font><font class="preprocessor">#define PLIB_NURBS_NURBSSUB_SOURCE</font>
00028 <font class="preprocessor"></font>
00029 <font class="preprocessor">#include "nurbsSub.h"</font>
00030 <font class="preprocessor">#include &lt;iostream&gt;</font>
00031 <font class="preprocessor">#include &lt;cstdio&gt;</font>
00032 <font class="preprocessor">#include &lt;stdio.h&gt;</font>
00033 
00036 <font class="keyword">namespace </font>PLib {
00037 
00038   
00039   <font class="keyword">const</font> <font class="keywordtype">int</font> FALSE_ = 0 ;
00040   <font class="keyword">const</font> <font class="keywordtype">int</font> TRUE_ = 1 ; 
00041 
00042   <font class="keyword">struct </font>BOOL{
00043     <font class="keywordtype">int</font> value ;
00044     BOOL(): value(FALSE_) {;}
00045     BOOL(<font class="keywordtype">int</font> a) { <font class="keywordflow">if</font>(a&gt;0) value=TRUE_; <font class="keywordflow">else</font> value=FALSE_;}
00046     BOOL(<font class="keyword">const</font> BOOL&amp; b) { value = b.value ; }
00047     <font class="keywordtype">int</font> operator!() { <font class="keywordflow">if</font>(value&gt;0) <font class="keywordflow">return</font> FALSE_; <font class="keywordflow">return</font> TRUE_ ;}
00048     operator int()<font class="keyword"> const </font>{<font class="keywordflow">return</font> value;}
00049     <font class="keywordtype">int</font>&amp; operator=(<font class="keywordtype">int</font> a) { value = a ;  <font class="keywordflow">return</font> value ; }
00050   };
00051 
00062   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00063"></a><a class="code" href="classPLib_1_1NurbsSubSurface.html#a0" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#a0">00063</a>     NurbsSubSurface&lt;T&gt;::NurbsSubSurface(<font class="keyword">const</font> NurbsSurface&lt;T,3&gt;&amp; s): rsurf(s) {
00064     surf = 0 ;
00065     render = 0 ; 
00066     <font class="comment">//initSurf();</font>
00067     
00068   }
00069 
00070 <font class="preprocessor">#define MAXORDER 20         </font><font class="comment">/* Maximum order allowed (for local array sizes) */</font>
00071 
00072   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
00073     <font class="keyword">struct </font>NurbSurface {
00074       <font class="comment">/* Number of Points in the U and V directions, respectivly */</font>
00075       <font class="keywordtype">int</font> numU, numV;
00076       <font class="comment">/* Order of the surface in U and V (must be &gt;= 2, &lt; MAXORDER) */</font>
00077       <font class="keywordtype">int</font> orderU, orderV;
00078       <font class="comment">/* Knot vectors, indexed as [0..numU+orderU-1] and [0..numV+orderV-1] */</font>
00079       T * kvU, * kvV;
00080       <font class="comment">/* Control points, indexed as points[0..numV-1][0..numU-1] */</font>
00081       <font class="comment">/* Note the w values are *premultiplied* with the x, y and z values */</font>
00082       Matrix&lt;HPoint_nD&lt;T,3&gt; &gt;&amp; points;
00083       
00084       <font class="comment">/* These fields are added to support subdivision */</font>
00085       BOOL strV0, strVn,   <font class="comment">/* Edge straightness flags for subdivision */</font>
00086       strU0, strUn;
00087       BOOL flatV, flatU;   <font class="comment">/* Surface flatness flags for subdivision */</font>
00088       SurfSample&lt;T&gt; c00, c0n,
00089       cn0, cnn;    <font class="comment">/* Corner data structures for subdivision */</font>
00090       RenderMesh&lt;T&gt; *render;
00091       
00092       <font class="keyword">static</font> T epsilon ;
00093       
00094       NurbSurface(): points(tmpPoints) {   render = 0 ; }
00095       NurbSurface(Matrix&lt;HPoint_nD&lt;T,3&gt; &gt;&amp; s, <font class="keywordtype">int</font> du, <font class="keywordtype">int</font> dv);
00096       
00097     <font class="keyword">protected</font>:
00098       Matrix&lt;HPoint_nD&lt;T,3&gt; &gt; tmpPoints ;
00099       
00100     };
00101 
00102 <font class="preprocessor">#define CHECK( n ) \</font>
00103 <font class="preprocessor">  { if (!(n)) { fprintf( stderr, "Ran out of memory\n" ); exit(-1); } }</font>
00104 <font class="preprocessor"></font>
00105 <font class="preprocessor">#define DIVW( rpt, pt ) \</font>
00106 <font class="preprocessor">  { (pt)-&gt;x() = (rpt)-&gt;x() / (rpt)-&gt;w(); \</font>
00107 <font class="preprocessor">  (pt)-&gt;y() = (rpt)-&gt;y() / (rpt)-&gt;w(); \</font>
00108 <font class="preprocessor">  (pt)-&gt;z() = (rpt)-&gt;z() / (rpt)-&gt;w(); }</font>
00109 <font class="preprocessor"></font>  
00110   
00111   <font class="comment">/* Function prototypes */</font>
00112   
00113   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font> DrawSubdivision( NurbSurface&lt;T&gt; *, T tolerance );
00114   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font> DrawEvaluation( NurbSurface&lt;T&gt; * );
00115   
00116   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">int</font> FindBreakPoint( T u, T * kv, <font class="keywordtype">int</font> m, <font class="keywordtype">int</font> k );
00117   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font> AllocNurb( NurbSurface&lt;T&gt; *, T *, T * );
00118   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font> CloneNurb( NurbSurface&lt;T&gt; *, NurbSurface&lt;T&gt; * );
00119   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font> FreeNurb( NurbSurface&lt;T&gt; * );
00120   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font> RefineSurface( NurbSurface&lt;T&gt; *, NurbSurface&lt;T&gt; *, BOOL );
00121   
00122   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font> CalcPoint( T, T, NurbSurface&lt;T&gt; *, Point_nD&lt;T,3&gt; *, Point_nD&lt;T,3&gt; *, Point_nD&lt;T,3&gt; * );
00123   
00124   
00135   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00136"></a><a class="code" href="classPLib_1_1NurbsSubSurface.html#b0" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#b0">00136</a>     <font class="keywordtype">void</font> NurbsSubSurface&lt;T&gt;::drawSubdivision(T tolerance)
00137     {
00138       <a class="code" href="classPLib_1_1NurbsSubSurface.html#b1" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#b1">initSurf</a>();
00139       surf-&gt;render = render ; 
00140       DrawSubdivision(surf,tolerance);
00141     }
00142   
00152   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00153"></a><a class="code" href="classPLib_1_1NurbsSubSurface.html#a3" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#a3">00153</a>     <font class="keywordtype">void</font> NurbsSubSurface&lt;T&gt;::drawSubdivisionPS(<font class="keyword">const</font> <font class="keywordtype">char</font>* f, T tolerance)
00154     {
00155       ofstream fout ;
00156       fout.open(f) ;
00157       <font class="keywordflow">if</font>(fout)
00158         <a class="code" href="classPLib_1_1NurbsSubSurface.html#a2" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#a2">drawSubdivisionPS</a>(fout,tolerance) ;
00159       fout.close();
00160     }
00161 
00172   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00173"></a><a class="code" href="classPLib_1_1NurbsSubSurface.html#a5" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#a5">00173</a>     <font class="keywordtype">void</font> NurbsSubSurface&lt;T&gt;::drawSubdivisionVRML(<font class="keyword">const</font> <font class="keywordtype">char</font>* f, T tolerance, <font class="keyword">const</font> Color&amp; col)
00174     {
00175       ofstream fout ;
00176       fout.open(f) ;
00177       <font class="keywordflow">if</font>(fout)
00178         <a class="code" href="classPLib_1_1NurbsSubSurface.html#a4" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#a4">drawSubdivisionVRML</a>(fout,tolerance,col) ;
00179       fout.close();
00180     }
00181 
00192   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00193"></a><a class="code" href="classPLib_1_1NurbsSubSurface.html#a7" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#a7">00193</a>     <font class="keywordtype">void</font> NurbsSubSurface&lt;T&gt;::drawSubdivisionVRML97(<font class="keyword">const</font> <font class="keywordtype">char</font>* f, T tolerance, <font class="keyword">const</font> Color&amp; col)
00194     {
00195       ofstream fout ;
00196       fout.open(f) ;
00197       <font class="keywordflow">if</font>(fout)
00198         <a class="code" href="classPLib_1_1NurbsSubSurface.html#a6" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#a6">drawSubdivisionVRML97</a>(fout,tolerance,col) ;
00199       fout.close();
00200     }
00201 
00212   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00213"></a><a class="code" href="classPLib_1_1NurbsSubSurface.html#a2" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#a2">00213</a>     <font class="keywordtype">void</font> NurbsSubSurface&lt;T&gt;::drawSubdivisionPS(ostream &amp;os, T tolerance)
00214     {
00215       <font class="keywordflow">if</font>(render)
00216         <font class="keyword">delete</font> render ;
00217       render = <font class="keyword">new</font> RenderMeshPS&lt;T&gt;(os) ;
00218       <a class="code" href="classPLib_1_1NurbsSubSurface.html#b0" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#b0">drawSubdivision</a>(tolerance) ;
00219     }
00220 
00231   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00232"></a><a class="code" href="classPLib_1_1NurbsSubSurface.html#a4" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#a4">00232</a>     <font class="keywordtype">void</font> NurbsSubSurface&lt;T&gt;::drawSubdivisionVRML(ostream &amp;os, T tolerance, <font class="keyword">const</font> Color&amp; col)
00233     {
00234       <font class="keywordflow">if</font>(render) 
00235         <font class="keyword">delete</font> render ;
00236       render = <font class="keyword">new</font> RenderMeshVRML&lt;T&gt;(os,col) ;
00237       <a class="code" href="classPLib_1_1NurbsSubSurface.html#b0" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#b0">drawSubdivision</a>(tolerance) ;
00238     }
00239 
00250   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00251"></a><a class="code" href="classPLib_1_1NurbsSubSurface.html#a6" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#a6">00251</a>     <font class="keywordtype">void</font> NurbsSubSurface&lt;T&gt;::drawSubdivisionVRML97(ostream &amp;os, T tolerance, <font class="keyword">const</font> Color&amp; col)
00252     {
00253       <font class="keywordflow">if</font>(render) 
00254         <font class="keyword">delete</font> render ;
00255       render = <font class="keyword">new</font> RenderMeshVRML97&lt;T&gt;(os,col) ;
00256       <a class="code" href="classPLib_1_1NurbsSubSurface.html#b0" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#b0">drawSubdivision</a>(tolerance) ;
00257     }
00258 
00269   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
00270   <font class="comment">//void NurbsSubSurface&lt;T&gt;::drawSubdivisionPoints(vector&lt;Point_nD&lt;T,3&gt; &gt; &amp;pnts, T tolerance)</font>
<a name="l00271"></a><a class="code" href="classPLib_1_1NurbsSubSurface.html#a8" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#a8">00271</a>   <font class="keywordtype">void</font> NurbsSubSurface&lt;T&gt;::drawSubdivisionPoints(BasicArray&lt;Point_nD&lt;T,3&gt; &gt;&amp;pnts, T tolerance)
00272     {
00273       <font class="keywordflow">if</font>(render) 
00274         <font class="keyword">delete</font> render ;
00275       render = <font class="keyword">new</font> RenderMeshPoints&lt;T&gt;(pnts) ;
00276       <a class="code" href="classPLib_1_1NurbsSubSurface.html#b0" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#b0">drawSubdivision</a>(tolerance) ;
00277     }
00278 
00288   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00289"></a><a class="code" href="classPLib_1_1NurbsSubSurface.html#b1" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#b1">00289</a>     <font class="keywordtype">void</font> NurbsSubSurface&lt;T&gt;::initSurf()
00290     {
00291       <font class="keywordflow">if</font>(surf)
00292         <font class="keyword">delete</font> surf ;
00293       surf = <font class="keyword">new</font> NurbSurface&lt;T&gt; ;
00294       surf-&gt;numU = rsurf.ctrlPnts().rows() ;
00295       surf-&gt;numV = rsurf.ctrlPnts().cols() ; 
00296       surf-&gt;orderU = rsurf.degreeU()+1 ;
00297       surf-&gt;orderV = rsurf.degreeV()+1 ;
00298       surf-&gt;kvU = <font class="keyword">new</font> T[surf-&gt;numU + surf-&gt;orderU];
00299       surf-&gt;kvV = <font class="keyword">new</font> T[surf-&gt;numV + surf-&gt;orderV];
00300       surf-&gt;points.resize(surf-&gt;numV,surf-&gt;numU);
00301       
00302       surf-&gt;flatV = FALSE_;
00303       surf-&gt;flatU = FALSE_;
00304       surf-&gt;strU0 = FALSE_;
00305       surf-&gt;strUn = FALSE_;
00306       surf-&gt;strV0 = FALSE_;
00307       surf-&gt;strVn = FALSE_;
00308 
00309       surf-&gt;render = render ; 
00310      
00311       <font class="keywordtype">int</font> i;
00312       <font class="keywordflow">for</font>(i=rsurf.knotU().n()-1;i&gt;=0;--i){
00313         surf-&gt;kvU[i] = rsurf.knotU()[i] ;
00314       }
00315       <font class="keywordflow">for</font>(i=rsurf.knotV().n()-1;i&gt;=0;--i){
00316         surf-&gt;kvV[i] = rsurf.knotV()[i] ;
00317       }
00318       <font class="keywordflow">for</font>(i=rsurf.ctrlPnts().rows()-1;i&gt;=0;--i)
00319         <font class="keywordflow">for</font>(<font class="keywordtype">int</font> j=rsurf.ctrlPnts().cols()-1;j&gt;=0;--j)
00320           surf-&gt;points(j,i) = rsurf.ctrlPnts()(i,j) ; 
00321     }
00322   
00323   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
00324     NurbSurface&lt;T&gt;::NurbSurface(Matrix&lt;HPoint_nD&lt;T,3&gt; &gt;&amp; s, <font class="keywordtype">int</font> du, <font class="keywordtype">int</font> dv): points(s), orderU(du+1), orderV(dv+1){
00325     numU = points.rows() ;
00326     numV = points.cols() ;
00327     kvU = <font class="keyword">new</font> T[numU + orderU] ;
00328     kvV = <font class="keyword">new</font> T[numV + orderV] ; 
00329     render = 0 ; 
00330   }
00331   
00338   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00339"></a><a class="code" href="classPLib_1_1NurbsSubSurface.html#a1" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1NurbsSubSurface.html#a1">00339</a>     NurbsSubSurface&lt;T&gt;::~NurbsSubSurface()
00340     {      
00341       <font class="keywordflow">if</font>(surf){
00342         <font class="keyword">delete</font> []surf-&gt;kvU ;
00343         <font class="keyword">delete</font> []surf-&gt;kvV ;
00344       }
00345     }
00346   
00361   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00362"></a><a class="code" href="classPLib_1_1RenderMeshPS.html#a6" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshPS.html#a6">00362</a>     <font class="keywordtype">void</font> RenderMeshPS&lt;T&gt;::screenProject(<font class="keyword">const</font> HPoint_nD&lt;T,3&gt; &amp;worldPt, Point_nD&lt;T,3&gt; &amp;screenPt )
00363     {
00364       screenPt.x() = worldPt.x() / worldPt.w() * 100 + 200;
00365       screenPt.y() = worldPt.y() / worldPt.w() * 100 + 200;
00366       screenPt.z() = worldPt.z() / worldPt.w() * 100 + 200;
00367     }
00368 
00381   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00382"></a><a class="code" href="classPLib_1_1RenderMeshVRML.html#a5" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshVRML.html#a5">00382</a>     <font class="keywordtype">void</font> RenderMeshVRML&lt;T&gt;::screenProject(<font class="keyword">const</font> HPoint_nD&lt;T,3&gt; &amp;worldPt, Point_nD&lt;T,3&gt; &amp;screenPt )
00383     {
00384       screenPt = project(worldPt) ;
00385     }
00386 
00387 
00400   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00401"></a><a class="code" href="classPLib_1_1RenderMeshVRML97.html#a5" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshVRML97.html#a5">00401</a>     <font class="keywordtype">void</font> RenderMeshVRML97&lt;T&gt;::screenProject(<font class="keyword">const</font> HPoint_nD&lt;T,3&gt; &amp;worldPt, Point_nD&lt;T,3&gt; &amp;screenPt )
00402     {      
00403       screenPt = project(worldPt) ;
00404       <font class="keywordflow">if</font>(init){
00405         p_min = p_max = screenPt ;
00406         init = 0 ; 
00407       }
00408       <font class="keywordflow">if</font>(screenPt.x()&lt;p_min.x()) p_min.x() = screenPt.x();
00409       <font class="keywordflow">if</font>(screenPt.y()&lt;p_min.y()) p_min.y() = screenPt.y();
00410       <font class="keywordflow">if</font>(screenPt.z()&lt;p_min.z()) p_min.z() = screenPt.z();
00411       <font class="keywordflow">if</font>(screenPt.x()&gt;p_max.x()) p_max.x() = screenPt.x();
00412       <font class="keywordflow">if</font>(screenPt.y()&gt;p_max.y()) p_max.y() = screenPt.y();
00413       <font class="keywordflow">if</font>(screenPt.z()&gt;p_max.z()) p_max.z() = screenPt.z();
00414     }
00415 
00416 
00429   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00430"></a><a class="code" href="classPLib_1_1RenderMeshPoints.html#a5" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshPoints.html#a5">00430</a>     <font class="keywordtype">void</font> RenderMeshPoints&lt;T&gt;::screenProject(<font class="keyword">const</font> HPoint_nD&lt;T,3&gt; &amp;worldPt, Point_nD&lt;T,3&gt; &amp;screenPt )
00431     {
00432       screenPt = project(worldPt) ;
00433     }
00434 
00435 
00436   <font class="keyword">inline</font> <font class="keywordtype">void</font> LineTo( ostream&amp; out, <font class="keywordtype">short</font> x, <font class="keywordtype">short</font> y )
00437     {
00438       out &lt;&lt; (int)x &lt;&lt; <font class="stringliteral">" "</font> &lt;&lt; (int)y &lt;&lt; <font class="stringliteral">" lineto\n"</font> ; 
00439     }
00440   
00441   <font class="keyword">inline</font> <font class="keywordtype">void</font> MoveTo( ostream&amp; out, <font class="keywordtype">short</font> x, <font class="keywordtype">short</font> y )
00442     {
00443       out &lt;&lt; (int)x &lt;&lt; <font class="stringliteral">" "</font> &lt;&lt; (int)y &lt;&lt; <font class="stringliteral">" moveto\n"</font> ; 
00444     }
00445   
00452   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00453"></a><a class="code" href="classPLib_1_1RenderMeshPS.html#a2" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshPS.html#a2">00453</a>   <font class="keywordtype">void</font> RenderMeshPS&lt;T&gt;::drawHeader(){
00454     out &lt;&lt; <font class="stringliteral">"%!PS-Adobe-2.1\n"</font>;
00455     out &lt;&lt; <font class="stringliteral">"%%Title: code5_0.ps (20)\n"</font> ;
00456     out &lt;&lt; <font class="stringliteral">"%%Creator: color_grid_generator\n"</font> ; 
00457     out &lt;&lt; <font class="stringliteral">"%%BoundingBox: 0 0 500 500\n"</font> ;
00458     out &lt;&lt; <font class="stringliteral">"%%Pages: 0\n"</font> ;
00459     out &lt;&lt; <font class="stringliteral">"%%EndComments\n"</font> ;
00460     out &lt;&lt; <font class="stringliteral">"0 setlinewidth\n"</font> ;
00461     out &lt;&lt; <font class="stringliteral">"0 0 0 setrgbcolor\n"</font> ;
00462   }
00463 
00470   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00471"></a><a class="code" href="classPLib_1_1RenderMeshPS.html#a5" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshPS.html#a5">00471</a>     <font class="keywordtype">void</font> RenderMeshPS&lt;T&gt;::drawFooter(){
00472     out &lt;&lt; <font class="stringliteral">"showpage\n%%EOF\n"</font> ; 
00473   }
00474 
00475 
00486   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00487"></a><a class="code" href="classPLib_1_1RenderMeshPS.html#a3" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshPS.html#a3">00487</a>     <font class="keywordtype">void</font> RenderMeshPS&lt;T&gt;::drawTriangle( <font class="keyword">const</font> SurfSample&lt;T&gt; &amp;v0, <font class="keyword">const</font> SurfSample&lt;T&gt; &amp;v1, <font class="keyword">const</font> SurfSample&lt;T&gt; &amp; v2 )
00488     {
00489       out &lt;&lt; <font class="stringliteral">"newpath\n"</font> ;
00490       MoveTo( out, (<font class="keywordtype">short</font>) (v0.point.x() * 100 + 200), (short) (v0.point.y() * 100 + 200) );
00491       LineTo( out, (<font class="keywordtype">short</font>) (v1.point.x() * 100 + 200), (short) (v1.point.y() * 100 + 200) );
00492       LineTo( out, (<font class="keywordtype">short</font>) (v2.point.x() * 100 + 200), (short) (v2.point.y() * 100 + 200) );
00493       LineTo( out, (<font class="keywordtype">short</font>) (v0.point.x() * 100 + 200), (short) (v0.point.y() * 100 + 200) );
00494       out &lt;&lt; <font class="stringliteral">"stroke\n"</font> ;
00495     }
00496 
00506   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00507"></a><a class="code" href="classPLib_1_1RenderMeshPS.html#a4" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshPS.html#a4">00507</a>     <font class="keywordtype">void</font> RenderMeshPS&lt;T&gt;::drawLine( <font class="keyword">const</font> SurfSample&lt;T&gt; &amp;v0, <font class="keyword">const</font> SurfSample&lt;T&gt; &amp;v1)
00508     {
00509       out &lt;&lt; <font class="stringliteral">"newpath\n"</font> ; 
00510       MoveTo(out , (<font class="keywordtype">short</font>) (v0.point.x() * 100 + 200), (short) (v0.point.y() * 100 + 200) );
00511       LineTo( out, (<font class="keywordtype">short</font>) (v1.point.x() * 100 + 200), (short) (v1.point.y() * 100 + 200) );
00512       out &lt;&lt; <font class="stringliteral">"stroke\n"</font> ; 
00513     }
00514 
00515 
00522   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00523"></a><a class="code" href="classPLib_1_1RenderMeshVRML97.html#a2" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshVRML97.html#a2">00523</a>     <font class="keywordtype">void</font> RenderMeshVRML97&lt;T&gt;::drawHeader()
00524     {
00525       size = 0 ; 
00526       out &lt;&lt; <font class="stringliteral">"#VRML V2.0 utf8\n"</font> ;
00527       out &lt;&lt; <font class="stringliteral">"#  Generated by Phil's NURBS library\n"</font> ;
00528       out &lt;&lt; <font class="stringliteral">"\nGroup {\n"</font> ;
00529       out &lt;&lt; <font class="stringliteral">"\n  children [\n"</font> ; 
00530       out &lt;&lt; <font class="stringliteral">"\tDEF T Transform {\n"</font>; 
00531       out &lt;&lt; <font class="stringliteral">"\t  children [\n"</font> ;
00532       out &lt;&lt; <font class="stringliteral">"\t\tShape {\n"</font> ;
00533       out &lt;&lt; <font class="stringliteral">"\t\t appearance Appearance {\n"</font> ; 
00534       out &lt;&lt; <font class="stringliteral">"\t\t\tmaterial Material{ diffuseColor "</font> &lt;&lt; float(color.r/255.0) &lt;&lt; <font class="charliteral">' '</font> &lt;&lt; <font class="keywordtype">float</font>(color.g/255.0) &lt;&lt; <font class="charliteral">' '</font> &lt;&lt; <font class="keywordtype">float</font>(color.b/255.0) &lt;&lt; <font class="stringliteral">" }\n"</font> ;
00535       out &lt;&lt; <font class="stringliteral">"\t\t }\n"</font> ; 
00536       out &lt;&lt; <font class="stringliteral">"\t\t geometry IndexedFaceSet {\n"</font> ;
00537       out &lt;&lt; <font class="stringliteral">"\t\t\tsolid FALSE\n"</font> ; 
00538       out &lt;&lt; <font class="stringliteral">"\t\t\tcoord Coordinate {\n"</font> ;
00539       out &lt;&lt; <font class="stringliteral">"\t\t\t point [\n"</font> ;
00540     }
00541  
00550   template &lt;class T&gt;
<a name="l00551"></a><a class="code" href="classPLib_1_1RenderMeshVRML97.html#a4" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshVRML97.html#a4">00551</a>     <font class="keywordtype">void</font> RenderMeshVRML97&lt;T&gt;::<a class="code" href="classPLib_1_1RenderMeshVRML97.html#a4" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshVRML97.html#a4">drawFooter</a>(){
00552 
00553     out &lt;&lt; <font class="stringliteral">"\t\t\t ]\n"</font> ; <font class="comment">// point [</font>
00554     out &lt;&lt; <font class="stringliteral">"\t\t\t}\n"</font> ; <font class="comment">// coord</font>
00555     
00556     out &lt;&lt; <font class="stringliteral">"\t\t\t coordIndex [\n"</font> ;
00557   
00558     <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i=0;i&lt;size;++i){
00559       out &lt;&lt; <font class="stringliteral">"\t\t\t\t"</font> &lt;&lt; 3*i &lt;&lt; <font class="stringliteral">", "</font> &lt;&lt; 3*i+1 &lt;&lt; <font class="stringliteral">", "</font> &lt;&lt; 3*i+2 &lt;&lt; <font class="stringliteral">", -1,\n"</font> ;
00560     }
00561     out &lt;&lt; <font class="stringliteral">"\t\t\t ]\n"</font> ;
00562     out &lt;&lt; <font class="stringliteral">"\t\t\t}\n"</font> ; <font class="comment">// IndexedFaceSet</font>
00563     out &lt;&lt; <font class="stringliteral">"\t\t}\n"</font> ;
00564     out &lt;&lt; <font class="stringliteral">"\t ]\n"</font> ; 
00565     out &lt;&lt; <font class="stringliteral">"\t}\n"</font> ;
00566     out &lt;&lt; <font class="stringliteral">"  ]\n"</font> ; 
00567     out &lt;&lt; <font class="stringliteral">"}\n"</font> ; 
00568     
00569     Point_nD&lt;T,3&gt; p_mid((p_max.x()+p_min.x())/T(2),
00570                         (p_max.y()+p_min.y())/T(2),
00571                         (p_max.z()+p_min.z())/T(2));
00572     
00573     T x_axis = p_max.x() - p_min.x() ;
00574     T y_axis = p_max.y() - p_min.y() ; 
00575     
00576     T axis = (x_axis&lt; y_axis) ? y_axis : x_axis ;
00577     axis *= T(2) ;
00578     
00579     out &lt;&lt; <font class="stringliteral">"Viewpoint {\n\t position "</font> &lt;&lt; p_mid.x() &lt;&lt; <font class="charliteral">' '</font> &lt;&lt; p_mid.y() &lt;&lt; <font class="charliteral">' '</font> &lt;&lt; p_max.z()+axis &lt;&lt; <font class="stringliteral">"\n\t description \"top\"\n}\n"</font> ; 
00580     
00581     
00582     out &lt;&lt; <font class="stringliteral">"NavigationInfo { type \"EXAMINE\" }\n"</font> ; 
00583 
00584   }
00585 
00592   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00593"></a><a class="code" href="classPLib_1_1RenderMeshVRML.html#a2" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshVRML.html#a2">00593</a>     <font class="keywordtype">void</font> RenderMeshVRML&lt;T&gt;::drawHeader()
00594     {
00595       size = 0 ; 
00596       out &lt;&lt; <font class="stringliteral">"#VRML V1.0 ascii\n"</font> ;
00597       out &lt;&lt; <font class="stringliteral">"#  Generated by Phil's NURBS library\n"</font> ;
00598       out &lt;&lt; <font class="stringliteral">"\nSeparator {\n"</font> &lt;&lt; <font class="stringliteral">"\tMaterialBinding { value PER_VERTEX_INDEXED }\n"</font>  ;
00599       out &lt;&lt; <font class="stringliteral">"\tMaterial{ ambientColor 0.25 0.25 0.25\n\t\tdiffuseColor "</font> &lt;&lt; float(color.r/255.0) &lt;&lt; <font class="charliteral">' '</font> &lt;&lt; <font class="keywordtype">float</font>(color.g/255.0) &lt;&lt; <font class="charliteral">' '</font> &lt;&lt; <font class="keywordtype">float</font>(color.b/255.0) &lt;&lt; <font class="stringliteral">" }\n"</font> ;
00600       out &lt;&lt; <font class="stringliteral">"\tCoordinate3 {\n"</font> ;
00601       out &lt;&lt; <font class="stringliteral">"\t\tpoint [\n"</font> ;
00602     }
00603  
00612   template &lt;class T&gt;
<a name="l00613"></a><a class="code" href="classPLib_1_1RenderMeshVRML.html#a4" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshVRML.html#a4">00613</a>     <font class="keywordtype">void</font> RenderMeshVRML&lt;T&gt;::<a class="code" href="classPLib_1_1RenderMeshVRML.html#a4" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshVRML.html#a4">drawFooter</a>(){
00614 
00615     out &lt;&lt; <font class="stringliteral">"\t\t]\n"</font> ; <font class="comment">// point [</font>
00616     out &lt;&lt; <font class="stringliteral">"\t}\n"</font> ; <font class="comment">// cordinate3</font>
00617     
00618     out &lt;&lt; <font class="stringliteral">"\tIndexedFaceSet{\n"</font> ;
00619     out &lt;&lt; <font class="stringliteral">"\t\tcoordIndex[\n"</font> ;
00620     
00621     <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i=0;i&lt;size;++i){
00622       out &lt;&lt; <font class="stringliteral">"\t\t\t"</font> &lt;&lt; 3*i &lt;&lt; <font class="stringliteral">", "</font> &lt;&lt; 3*i+1 &lt;&lt; <font class="stringliteral">", "</font> &lt;&lt; 3*i+2 &lt;&lt; <font class="stringliteral">", -1,\n"</font> ;
00623     }
00624     out &lt;&lt; <font class="stringliteral">"\t\t]\n"</font> ;
00625     out &lt;&lt; <font class="stringliteral">"\t}\n"</font> ; <font class="comment">// IndexedFaceSet</font>
00626     
00627     out &lt;&lt; <font class="stringliteral">"}\n"</font> ;
00628   }
00629 
00630 
00643   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00644"></a><a class="code" href="classPLib_1_1RenderMeshVRML.html#a3" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshVRML.html#a3">00644</a>     <font class="keywordtype">void</font> RenderMeshVRML&lt;T&gt;::drawTriangle(<font class="keyword">const</font> SurfSample&lt;T&gt; &amp;v0, <font class="keyword">const</font> SurfSample&lt;T&gt; &amp;v1, <font class="keyword">const</font> SurfSample&lt;T&gt; &amp; v2 )
00645     {
00646       ++size ;
00647       out &lt;&lt; <font class="stringliteral">"\t\t\t"</font> &lt;&lt; v0.point.x() &lt;&lt; <font class="stringliteral">" "</font> &lt;&lt; v0.point.y() &lt;&lt; <font class="stringliteral">" "</font> &lt;&lt; v0.point.z() &lt;&lt; <font class="stringliteral">",\n"</font> ;
00648       out &lt;&lt; <font class="stringliteral">"\t\t\t"</font> &lt;&lt; v1.point.x() &lt;&lt; <font class="stringliteral">" "</font> &lt;&lt; v1.point.y() &lt;&lt; <font class="stringliteral">" "</font> &lt;&lt; v1.point.z() &lt;&lt; <font class="stringliteral">",\n"</font> ;
00649       out &lt;&lt; <font class="stringliteral">"\t\t\t"</font> &lt;&lt; v2.point.x() &lt;&lt; <font class="stringliteral">" "</font> &lt;&lt; v2.point.y() &lt;&lt; <font class="stringliteral">" "</font> &lt;&lt; v2.point.z() &lt;&lt; <font class="stringliteral">",\n"</font> ;
00650       
00651     }
00652   
00665   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00666"></a><a class="code" href="classPLib_1_1RenderMeshVRML97.html#a3" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshVRML97.html#a3">00666</a>     <font class="keywordtype">void</font> RenderMeshVRML97&lt;T&gt;::drawTriangle(<font class="keyword">const</font> SurfSample&lt;T&gt; &amp;v0, <font class="keyword">const</font> SurfSample&lt;T&gt; &amp;v1, <font class="keyword">const</font> SurfSample&lt;T&gt; &amp; v2 )
00667     {
00668       ++size ;
00669       out &lt;&lt; <font class="stringliteral">"\t\t\t\t"</font> &lt;&lt; v0.point.x() &lt;&lt; <font class="stringliteral">" "</font> &lt;&lt; v0.point.y() &lt;&lt; <font class="stringliteral">" "</font> &lt;&lt; v0.point.z() &lt;&lt; <font class="stringliteral">",\n"</font> ;
00670       out &lt;&lt; <font class="stringliteral">"\t\t\t\t"</font> &lt;&lt; v1.point.x() &lt;&lt; <font class="stringliteral">" "</font> &lt;&lt; v1.point.y() &lt;&lt; <font class="stringliteral">" "</font> &lt;&lt; v1.point.z() &lt;&lt; <font class="stringliteral">",\n"</font> ;
00671       out &lt;&lt; <font class="stringliteral">"\t\t\t\t"</font> &lt;&lt; v2.point.x() &lt;&lt; <font class="stringliteral">" "</font> &lt;&lt; v2.point.y() &lt;&lt; <font class="stringliteral">" "</font> &lt;&lt; v2.point.z() &lt;&lt; <font class="stringliteral">",\n"</font> ;
00672       
00673     }
00674   
00681   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00682"></a><a class="code" href="classPLib_1_1RenderMeshPoints.html#a2" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshPoints.html#a2">00682</a>     <font class="keywordtype">void</font> RenderMeshPoints&lt;T&gt;::drawHeader()
00683     {
00684       points.clear();
00685     }
00686  
00694   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00695"></a><a class="code" href="classPLib_1_1RenderMeshPoints.html#a4" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshPoints.html#a4">00695</a>     <font class="keywordtype">void</font> RenderMeshPoints&lt;T&gt;::drawFooter(){
00696   }
00697 
00698 
00711   <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l00712"></a><a class="code" href="classPLib_1_1RenderMeshPoints.html#a3" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1RenderMeshPoints.html#a3">00712</a>     <font class="keywordtype">void</font> RenderMeshPoints&lt;T&gt;::drawTriangle(<font class="keyword">const</font> SurfSample&lt;T&gt; &amp;v0, <font class="keyword">const</font> SurfSample&lt;T&gt; &amp;v1, <font class="keyword">const</font> SurfSample&lt;T&gt; &amp; v2 )
00713     {
00714       <font class="comment">// naive method</font>
00715       points.push_back(v0.point);
00716       points.push_back(v1.point);
00717       points.push_back(v2.point);
00718     }
00719   
00720 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
00721 <font class="keywordtype">int</font>
00722 FindBreakPoint( T u, T * kv, <font class="keywordtype">int</font> m, <font class="keywordtype">int</font> k )
00723 {
00724   <font class="keywordtype">int</font> i;
00725   
00726   <font class="keywordflow">if</font> (u == kv[m+1])     <font class="comment">/* Special case for closed interval */</font>
00727     <font class="keywordflow">return</font> m;
00728   
00729   i = m + k;
00730   <font class="keywordflow">while</font> ((u &lt; kv[i]) &amp;&amp; (i &gt; 0))
00731     i--;
00732   <font class="keywordflow">return</font>( i );
00733 }
00734 
00735 <font class="comment">/*</font>
00736 <font class="comment"> * Compute Bi,k(u), for i = 0..k.</font>
00737 <font class="comment"> *  u           is the parameter of the spline to find the basis functions for</font>
00738 <font class="comment"> *  brkPoint    is the start of the knot interval ("segment")</font>
00739 <font class="comment"> *  kv          is the knot vector</font>
00740 <font class="comment"> *  k           is the order of the curve</font>
00741 <font class="comment"> *  bvals       is the array of returned basis values.</font>
00742 <font class="comment"> *</font>
00743 <font class="comment"> * (From Bartels, Beatty &amp; Barsky, p.387)</font>
00744 <font class="comment"> */</font>
00745 
00746 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font>
00747 BasisFunctions( T u, <font class="keywordtype">int</font> brkPoint, T * kv, <font class="keywordtype">int</font> k, T * bvals )
00748 {
00749   <font class="keywordtype">int</font> r, s, i;
00750   T omega;
00751   
00752   bvals[0] = 1.0;
00753   <font class="keywordflow">for</font> (r = 2; r &lt;= k; r++)
00754     {
00755       i = brkPoint - r + 1;
00756       bvals[r - 1] = 0.0;
00757       <font class="keywordflow">for</font> (s = r-2; s &gt;= 0; s--)
00758         {
00759           i++;
00760           <font class="keywordflow">if</font> (i &lt; 0)
00761             omega = 0;
00762           <font class="keywordflow">else</font>
00763             omega = (u - kv[i]) / (kv[i + r - 1] - kv[i]);
00764           bvals[s + 1] = bvals[s + 1] + (1 - omega) * bvals[s];
00765           bvals[s] = omega * bvals[s];
00766         }
00767     }
00768 }
00769 
00770 <font class="comment">/*</font>
00771 <font class="comment"> * Compute derivatives of the basis functions Bi,k(u)'</font>
00772 <font class="comment"> */</font>
00773 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font>
00774 BasisDerivatives( T u, <font class="keywordtype">int</font> brkPoint, T * kv, <font class="keywordtype">int</font> k, T * dvals )
00775 {
00776   <font class="keyword">register</font> <font class="keywordtype">int</font> s, i;
00777   T omega, knotScale;
00778 
00779   BasisFunctions( u, brkPoint, kv, k - 1, dvals );
00780   
00781   dvals[k-1] = 0.0;         <font class="comment">/* BasisFunctions misses this */</font>
00782   
00783   knotScale = kv[brkPoint + 1] - kv[brkPoint];
00784   
00785   i = brkPoint - k + 1;
00786   <font class="keywordflow">for</font> (s = k - 2; s &gt;= 0; s--)
00787     {
00788       i++;
00789       omega = knotScale * ((T)(k-1)) / (kv[i+k-1] - kv[i]);
00790       dvals[s + 1] += -omega * dvals[s];
00791       dvals[s] *= omega;
00792     }
00793 }
00794 
00795 <font class="comment">/*</font>
00796 <font class="comment"> * Calculate a point p on NurbSurface&lt;T&gt; n at a specific u, v using the tensor product.</font>
00797 <font class="comment"> * If utan and vtan are not nil, compute the u and v tangents as well.</font>
00798 <font class="comment"> *</font>
00799 <font class="comment"> * Note the valid parameter range for u and v is</font>
00800 <font class="comment"> * (kvU[orderU] &lt;= u &lt; kvU[numU), (kvV[orderV] &lt;= v &lt; kvV[numV])</font>
00801 <font class="comment"> */</font>
00802 
00803 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
00804 <font class="keywordtype">void</font>
00805 CalcPoint(T u, T v, NurbSurface&lt;T&gt; * n,
00806            Point_nD&lt;T,3&gt; * p, Point_nD&lt;T,3&gt; * utan, Point_nD&lt;T,3&gt; * vtan)
00807 {
00808   <font class="keywordtype">int</font> i, j, ri, rj;
00809   HPoint_nD&lt;T,3&gt; * cp;
00810   T tmp;
00811   T wsqrdiv;
00812   <font class="keywordtype">int</font> ubrkPoint, ufirst;
00813   T bu[MAXORDER], buprime[MAXORDER];
00814   <font class="keywordtype">int</font> vbrkPoint, vfirst;
00815   T bv[MAXORDER], bvprime[MAXORDER];
00816   HPoint_nD&lt;T,3&gt; r, rutan, rvtan;
00817   
00818   r.x() = 0.0;
00819   r.y() = 0.0;
00820   r.z() = 0.0;
00821   r.w() = 0.0;
00822   
00823   rutan = r;
00824   rvtan = r;
00825   
00826   <font class="comment">/* Evaluate non-uniform basis functions (and derivatives) */</font>
00827   
00828   ubrkPoint = FindBreakPoint( u, n-&gt;kvU, n-&gt;numU-1, n-&gt;orderU );
00829   ufirst = ubrkPoint - n-&gt;orderU + 1;
00830   BasisFunctions( u, ubrkPoint, n-&gt;kvU, n-&gt;orderU, bu );
00831   <font class="keywordflow">if</font> (utan)
00832     BasisDerivatives( u, ubrkPoint, n-&gt;kvU, n-&gt;orderU, buprime );
00833   
00834   vbrkPoint = FindBreakPoint( v, n-&gt;kvV, n-&gt;numV-1, n-&gt;orderV );
00835   vfirst = vbrkPoint - n-&gt;orderV + 1;
00836   BasisFunctions( v, vbrkPoint, n-&gt;kvV, n-&gt;orderV, bv );
00837   <font class="keywordflow">if</font> (vtan)
00838     BasisDerivatives( v, vbrkPoint, n-&gt;kvV, n-&gt;orderV, bvprime );
00839   
00840   <font class="comment">/* Weight control points against the basis functions */</font>
00841   
00842   <font class="keywordflow">for</font> (i = 0; i &lt; n-&gt;orderV; i++)
00843     <font class="keywordflow">for</font> (j = 0; j &lt; n-&gt;orderU; j++)
00844         {
00845           ri = n-&gt;orderV - 1 - i;
00846           rj = n-&gt;orderU - 1 - j;
00847           
00848           tmp = bu[rj] * bv[ri];
00849           cp = &amp;( n-&gt;points(i+vfirst,j+ufirst) );
00850           r.x() += cp-&gt;x() * tmp;
00851           r.y() += cp-&gt;y() * tmp;
00852           r.z() += cp-&gt;z() * tmp;
00853           r.w() += cp-&gt;w() * tmp;
00854 
00855           <font class="keywordflow">if</font> (utan)
00856             {
00857               tmp = buprime[rj] * bv[ri];
00858               rutan.x() += cp-&gt;x() * tmp;
00859               rutan.y() += cp-&gt;y() * tmp;
00860               rutan.z() += cp-&gt;z() * tmp;
00861               rutan.w() += cp-&gt;w() * tmp;
00862             }
00863           <font class="keywordflow">if</font> (vtan)
00864             {
00865               tmp = bu[rj] * bvprime[ri];
00866               rvtan.x() += cp-&gt;x() * tmp;
00867               rvtan.y() += cp-&gt;y() * tmp;
00868               rvtan.z() += cp-&gt;z() * tmp;
00869               rvtan.w() += cp-&gt;w() * tmp;
00870             }
00871         }
00872   
00873   <font class="comment">/* Project tangents, using the quotient rule for differentiation */</font>
00874   
00875   wsqrdiv = 1.0 / (r.w() * r.w());
00876   <font class="keywordflow">if</font> (utan)
00877     {
00878       utan-&gt;x() = (r.w() * rutan.x() - rutan.w() * r.x()) * wsqrdiv;
00879       utan-&gt;y() = (r.w() * rutan.y() - rutan.w() * r.y()) * wsqrdiv;
00880       utan-&gt;z() = (r.w() * rutan.z() - rutan.w() * r.z()) * wsqrdiv;
00881     }
00882   <font class="keywordflow">if</font> (vtan)
00883     {
00884       vtan-&gt;x() = (r.w() * rvtan.x() - rvtan.w() * r.x()) * wsqrdiv;
00885       vtan-&gt;y() = (r.w() * rvtan.y() - rvtan.w() * r.y()) * wsqrdiv;
00886       vtan-&gt;z() = (r.w() * rvtan.z() - rvtan.w() * r.z()) * wsqrdiv;
00887     }
00888   
00889   p-&gt;x() = r.x() / r.w();
00890   p-&gt;y() = r.y() / r.w();
00891   p-&gt;z() = r.z() / r.w();
00892 }
00893 
00894 <font class="comment">/*</font>
00895 <font class="comment"> * Draw a mesh of points by evaluating the surface at evenly spaced</font>
00896 <font class="comment"> * points.</font>
00897 <font class="comment"> */</font>
00898 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
00899 <font class="keywordtype">void</font>
00900 DrawEvaluation( NurbSurface&lt;T&gt; * n )
00901 {
00902   Point_nD&lt;T,3&gt; p, utan, vtan;
00903   <font class="keyword">register</font> <font class="keywordtype">int</font> i, j;
00904   <font class="keyword">register</font> T u, v, d;
00905   SurfSample&lt;T&gt; ** pts ;
00906   
00907   <font class="keywordtype">int</font> Granularity = 10;  <font class="comment">/* Controls the number of steps in u and v */</font>
00908   
00909   <font class="comment">/* Allocate storage for the grid of points generated */</font>
00910   
00911   CHECK( pts = <font class="keyword">new</font> (SurfSample&lt;T&gt;*)[Granularity+1]);
00912   CHECK( pts[0] = <font class="keyword">new</font> SurfSample&lt;T&gt;[(Granularity+1)*(Granularity+1)]);
00913   
00914   <font class="keywordflow">for</font> (i = 1; i &lt;= Granularity; i++)
00915     pts[i] = &amp;(pts[0][(Granularity+1) * i]);
00916   
00917   <font class="comment">/* Compute points on curve */</font>
00918   
00919   <font class="keywordflow">for</font> (i = 0; i &lt;= Granularity; i++)
00920     {
00921       v = ((T) i / (T) Granularity)
00922             * (n-&gt;kvV[n-&gt;numV] - n-&gt;kvV[n-&gt;orderV-1])
00923         + n-&gt;kvV[n-&gt;orderV-1];
00924       
00925       <font class="keywordflow">for</font> (j = 0; j &lt;= Granularity; j++)
00926         {
00927           u = ((T) j / (T) Granularity)
00928             * (n-&gt;kvU[n-&gt;numU] - n-&gt;kvU[n-&gt;orderU-1])
00929             + n-&gt;kvU[n-&gt;orderU-1];
00930           
00931           CalcPoint( u, v, n, &amp;(pts[i][j].point), &amp;utan, &amp;vtan );
00932           p = crossProduct(utan,vtan) ; <font class="comment">//(void) V3Cross( &amp;utan, &amp;vtan, &amp;p );</font>
00933           d = norm(p) ; <font class="comment">// d = V3Length( &amp;p );</font>
00934           <font class="keywordflow">if</font> (d != 0.0)
00935             {
00936               p.x() /= d;
00937               p.y() /= d;
00938               p.z() /= d;
00939             }
00940           <font class="keywordflow">else</font>
00941             {
00942               p.x() = 0;
00943               p.y() = 0;
00944               p.z() = 0;
00945             }
00946           pts[i][j].normLen = d;
00947           pts[i][j].normal = p;
00948           pts[i][j].u = u;
00949           pts[i][j].v = v;
00950         }
00951     }
00952   
00953   <font class="comment">/* Draw the grid */</font>
00954   
00955   <font class="keywordflow">for</font> (i = 0; i &lt; Granularity; i++)
00956     <font class="keywordflow">for</font> (j = 0; j &lt; Granularity; j++)
00957       {
00958         n-&gt;render-&gt;drawTriangle( pts[i][j], pts[i+1][j+1], pts[i+1][j] );
00959         n-&gt;render-&gt;drawTriangle( pts[i][j], pts[i][j+1],   pts[i+1][j+1] );
00960       }
00961   
00962   <font class="keyword">delete</font> [] pts[0];
00963   <font class="keyword">delete</font> [] pts ;
00964 }
00965 
00966 <font class="comment">/*</font>
00967 <font class="comment"> * NurbRefine.c - Given a refined knot vector, add control points to a surface.</font>
00968 <font class="comment"> *</font>
00969 <font class="comment"> * John Peterson</font>
00970 <font class="comment"> */</font>
00971 
00972 
00973 <font class="comment">/*</font>
00974 <font class="comment"> * Given the original knot vector ukv, and a new knotvector vkv, compute</font>
00975 <font class="comment"> * the "alpha matrix" used to generate the corresponding new control points.</font>
00976 <font class="comment"> * This routines allocates the alpha matrix if it isn't allocated already.</font>
00977 <font class="comment"> *</font>
00978 <font class="comment"> * This is from Bartels, Beatty &amp; Barsky, p. 407</font>
00979 <font class="comment"> */</font>
00980 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font>
00981 CalcAlpha( T * ukv, T * wkv, <font class="keywordtype">int</font> m, <font class="keywordtype">int</font> n, <font class="keywordtype">int</font> k, T *** alpha )
00982 {
00983   <font class="keywordtype">int</font> i, j;
00984   <font class="keywordtype">int</font> brkPoint, r, rm1, last, s;
00985   T omega;
00986   T aval[MAXORDER];
00987   
00988   <font class="keywordflow">if</font> (! *alpha) <font class="comment">/* Must allocate alpha */</font>
00989     {
00990       CHECK( *alpha = <font class="keyword">new</font> (T*)[k+1]);
00991       <font class="keywordflow">for</font> (i = 0; i &lt;= k; i++)
00992         CHECK( (*alpha)[i] = <font class="keyword">new</font> T[(m + n + 1)]);
00993     }
00994   
00995   <font class="keywordflow">for</font> (j = 0; j &lt;= m + n; j++)
00996     {
00997       brkPoint = FindBreakPoint( wkv[j], ukv, m, k );
00998       aval[0] = 1.0;
00999       <font class="keywordflow">for</font> (r = 2; r &lt;= k; r++)
01000         {
01001           rm1 = r - 1;
01002           last = minimum( rm1, brkPoint );
01003           i = brkPoint - last;
01004           <font class="keywordflow">if</font> (last &lt; rm1)
01005             aval[last] = aval[last] * (wkv[j + r - 1] - ukv[i])
01006               / (ukv[i + r - 1] - ukv[i]);
01007           <font class="keywordflow">else</font>
01008             aval[last] = 0.0;
01009           
01010           <font class="keywordflow">for</font> (s = last - 1; s &gt;= 0; s-- )
01011             {
01012               i++;
01013               omega = (wkv[j + r - 1] - ukv[i]) / (ukv[i + r - 1] - ukv[i]);
01014               aval[s + 1] = aval[s+1] + (1 - omega) * aval[s];
01015               aval[s] = omega * aval[s];
01016             }
01017         }
01018       last = minimum( k - 1, brkPoint );
01019       <font class="keywordflow">for</font> (i = 0; i &lt;= k; i++)
01020         (*alpha)[i][j] = 0.0;
01021       <font class="keywordflow">for</font> (s = 0; s &lt;= last; s++)
01022         (*alpha)[last - s][j] = aval[s];
01023     }
01024 }
01025 
01026 <font class="comment">/*</font>
01027 <font class="comment"> * Apply the alpha matrix computed above to the rows (or columns)</font>
01028 <font class="comment"> * of the surface.  If dirflag is TRUE_ do the U's (row), else do V's (col).</font>
01029 <font class="comment"> */</font>
01030 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
01031 <font class="keywordtype">void</font>
01032 RefineSurface( NurbSurface&lt;T&gt; * src, NurbSurface&lt;T&gt; * dest, BOOL dirflag )
01033 {
01034   <font class="keywordtype">int</font> i, j, out;
01035   HPoint_nD&lt;T,3&gt; * dp, * sp;
01036   <font class="keywordtype">int</font> i1, brkPoint, maxj, maxout;
01037   <font class="keyword">register</font> T tmp;
01038   T ** alpha = 0;
01039   
01040   <font class="comment">// Compute the alpha matrix and indexing variables for the requested direction </font>
01041   
01042   <font class="keywordflow">if</font> (dirflag)
01043     {
01044       CalcAlpha( src-&gt;kvU, dest-&gt;kvU, src-&gt;numU - 1, dest-&gt;numU - src-&gt;numU,
01045                  src-&gt;orderU, &amp;alpha );
01046       maxj = dest-&gt;numU;
01047       maxout = src-&gt;numV;
01048     }
01049   <font class="keywordflow">else</font>
01050     {
01051       CalcAlpha( src-&gt;kvV, dest-&gt;kvV, src-&gt;numV - 1, dest-&gt;numV - src-&gt;numV,
01052                  src-&gt;orderV, &amp;alpha );
01053       maxj = dest-&gt;numV;
01054       maxout = dest-&gt;numU;
01055     }
01056   
01057   <font class="comment">/* Apply the alpha matrix to the original control points, generating new ones */</font>
01058   
01059   <font class="keywordflow">for</font> (out = 0; out &lt; maxout; out++)
01060     <font class="keywordflow">for</font> (j = 0; j &lt; maxj; j++)
01061       {
01062         <font class="keywordflow">if</font> (dirflag)
01063           {
01064             dp = &amp;(dest-&gt;points(out,j));
01065             brkPoint = FindBreakPoint( dest-&gt;kvU[j], src-&gt;kvU,
01066                                        src-&gt;numU-1, src-&gt;orderU );
01067             i1 = maximum( brkPoint - src-&gt;orderU + 1, 0 );
01068             sp = &amp;(src-&gt;points(out,i1));
01069           } <font class="keywordflow">else</font> {
01070             dp = &amp;(dest-&gt;points(j,out));
01071             brkPoint = FindBreakPoint( dest-&gt;kvV[j], src-&gt;kvV,
01072                                        src-&gt;numV-1, src-&gt;orderV );
01073             i1 = maximum( brkPoint - src-&gt;orderV + 1, 0 );
01074             sp = &amp;(src-&gt;points(i1,out));
01075           }
01076         dp-&gt;x() = 0.0;
01077         dp-&gt;y() = 0.0;
01078         dp-&gt;z() = 0.0;
01079         dp-&gt;w() = 0.0;
01080         <font class="keywordflow">for</font> (i = i1; i &lt;= brkPoint; i++)
01081           {
01082             tmp = alpha[i - i1][j];
01083             sp = (dirflag ? &amp;(src-&gt;points(out,i)) : &amp;(src-&gt;points(i,out)) );
01084             dp-&gt;x() += tmp * sp-&gt;x();
01085             dp-&gt;y() += tmp * sp-&gt;y();
01086             dp-&gt;z() += tmp * sp-&gt;z();
01087             dp-&gt;w() += tmp * sp-&gt;w();
01088           }
01089       }
01090   
01091   <font class="comment">/* Free up the alpha matrix */</font>
01092   <font class="keywordflow">for</font> (i = 0; i &lt;= (dirflag ? src-&gt;orderU : src-&gt;orderV); i++)
01093     <font class="keyword">delete</font> [] alpha[i] ;
01094   <font class="keyword">delete</font> [] alpha ;
01095 }
01096 
01097 <font class="comment">/*</font>
01098 <font class="comment"> * NurbUtils.c - Code for Allocating, freeing, &amp; copying NURB surfaces.</font>
01099 <font class="comment"> *</font>
01100 <font class="comment"> * John Peterson</font>
01101 <font class="comment"> */</font>
01102 
01103 
01104 <font class="comment">/*</font>
01105 <font class="comment"> * Allocate memory for a NURB (assumes numU, numV, orderU</font>
01106 <font class="comment"> * and orderV have been set).  If ukv or vkv are not NIL, they</font>
01107 <font class="comment"> * are assumed to be pointers to valid knot vectors.</font>
01108 <font class="comment"> */</font>
01109 
01110 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
01111 <font class="keywordtype">void</font>
01112 AllocNurb( NurbSurface&lt;T&gt; * n, T * ukv, T * vkv )
01113 {
01114   <font class="keywordtype">int</font> i;
01115   
01116   <font class="keywordflow">if</font> (! ukv)
01117     n-&gt;kvU = <font class="keyword">new</font> T[n-&gt;numU + n-&gt;orderU] ;
01118   <font class="keywordflow">else</font>
01119     n-&gt;kvU = ukv;
01120   <font class="keywordflow">if</font> (! vkv)
01121     n-&gt;kvV = <font class="keyword">new</font> T[n-&gt;numV + n-&gt;orderV];
01122   <font class="keywordflow">else</font>
01123     n-&gt;kvV = vkv;
01124   
01125   n-&gt;points.resize(n-&gt;numV,n-&gt;numU) ;
01126 }
01127 
01128 <font class="comment">/*</font>
01129 <font class="comment"> * Release storage for a patch</font>
01130 <font class="comment"> */</font>
01131 
01132 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
01133 <font class="keywordtype">void</font>
01134 FreeNurb( NurbSurface&lt;T&gt; * n )
01135 {
01136   <font class="keywordtype">int</font> i;
01137   
01138   <font class="keywordflow">if</font> (n-&gt;kvU) <font class="keyword">delete</font> [] n-&gt;kvU ;
01139   n-&gt;kvU = 0;
01140   <font class="keywordflow">if</font> (n-&gt;kvV) <font class="keyword">delete</font> [] n-&gt;kvV ;
01141   n-&gt;kvV = 0;
01142   <font class="keyword">delete</font> n ; 
01143   n = 0 ; 
01144   <font class="comment">// Don't touch render, it might still be used.</font>
01145 }
01146 
01147 <font class="comment">/*</font>
01148 <font class="comment"> * Clone a nurb (deep copy)</font>
01149 <font class="comment"> */</font>
01150 
01151 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
01152 <font class="keywordtype">void</font>
01153 CloneNurb( NurbSurface&lt;T&gt; * src, NurbSurface&lt;T&gt; * dst )
01154 {
01155   <font class="keywordtype">int</font> i, j;
01156   T * srcp, *dstp;
01157   
01158   <font class="comment">//*dst = *src;        /* Copy fields that don't change */</font>
01159   dst-&gt;numU = src-&gt;numU ;
01160   dst-&gt;numV = src-&gt;numV ;
01161   dst-&gt;orderU = src-&gt;orderU ;
01162   dst-&gt;orderV = src-&gt;orderV ;
01163   
01164   dst-&gt;strU0 = src-&gt;strU0 ; 
01165   dst-&gt;strUn = src-&gt;strUn ; 
01166   dst-&gt;strV0 = src-&gt;strV0 ; 
01167   dst-&gt;strVn = src-&gt;strVn ; 
01168   
01169   dst-&gt;kvU = 0;
01170   dst-&gt;kvV = 0; <font class="comment">/* So they get allocated */</font>
01171   dst-&gt;points = 0;
01172   
01173   AllocNurb( dst, (T*)0, (T*)0 );
01174   
01175   <font class="comment">/* Copy kv's */</font>
01176   srcp = src-&gt;kvU;
01177   dstp = dst-&gt;kvU;
01178   <font class="keywordflow">for</font> (i = 0; i &lt; src-&gt;numU + src-&gt;orderU; i++)
01179     *dstp++ = *srcp++;
01180   
01181   srcp = src-&gt;kvV;
01182   dstp = dst-&gt;kvV;
01183   <font class="keywordflow">for</font> (i = 0; i &lt; src-&gt;numV + src-&gt;orderV; i++)
01184     *dstp++ = *srcp++;
01185 
01186   <font class="comment">/* Copy control points */</font>
01187   <font class="keywordflow">for</font> (i = 0; i &lt; src-&gt;numV; i++)
01188     <font class="keywordflow">for</font> (j = 0; j &lt; src-&gt;numU; j++)
01189       dst-&gt;points(i,j) = src-&gt;points(i,j);
01190 }
01191 
01192 <font class="comment">/*</font>
01193 <font class="comment"> * NurbSubdiv.c - Perform adaptive subdivision on a NURB surface.</font>
01194 <font class="comment"> *</font>
01195 <font class="comment"> * John Peterson</font>
01196 <font class="comment"> *</font>
01197 <font class="comment"> */</font>
01198 
01199 <font class="preprocessor">#define DIVPT( p, dn ) { ((p).x()) /= (dn); ((p).y()) /= (dn); ((p).z()) /= (dn); }</font>
01200 <font class="preprocessor"></font>
01201 <font class="preprocessor">#define maxV(surf) ((surf)-&gt;numV-1)</font>
01202 <font class="preprocessor"></font><font class="preprocessor">#define maxU(surf) ((surf)-&gt;numU-1)</font>
01203 <font class="preprocessor"></font>
01204 <font class="comment">/*</font>
01205 <font class="comment"> * Split a knot vector at the center, by adding multiplicity k knots near</font>
01206 <font class="comment"> * the middle of the parameter range.  Tries to start with an existing knot,</font>
01207 <font class="comment"> * but will add a new knot value if there's nothing in "the middle" (e.g.,</font>
01208 <font class="comment"> * a Bezier curve).</font>
01209 <font class="comment"> */</font>
01210 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">int</font>
01211 SplitKV( T * srckv,
01212          T ** destkv,
01213          <font class="keywordtype">int</font> * splitPt,    <font class="comment">/* Where the knot interval is split */</font>
01214          <font class="keywordtype">int</font> m, <font class="keywordtype">int</font> k )
01215 {
01216   <font class="keywordtype">int</font> i, last;
01217   <font class="keywordtype">int</font> middex, extra, same;      <font class="comment">/* "middex" ==&gt; "middle index" */</font>
01218   T midVal;
01219   
01220   extra = 0;
01221   last = (m + k);
01222   
01223   middex = last / 2;
01224   midVal = srckv[middex];
01225   
01226   <font class="comment">/* Search forward and backward to see if multiple knot is already there */</font>
01227   
01228   i = middex+1;
01229   same = 1;
01230   <font class="keywordflow">while</font> ((i &lt; last) &amp;&amp; (srckv[i] == midVal)) {
01231     i++;
01232     same++;
01233   }
01234   
01235   i = middex-1;
01236   <font class="keywordflow">while</font> ((i &gt; 0) &amp;&amp; (srckv[i] == midVal)) {
01237     i--;
01238     middex--;       <font class="comment">/* middex is start of multiple knot */</font>
01239     same++;
01240   }
01241   
01242   <font class="keywordflow">if</font> (i &lt;= 0)       <font class="comment">/* No knot in middle, must create it */</font>
01243     {
01244       midVal = (srckv[0] + srckv[last]) / 2.0;
01245       middex = last / 2;
01246       <font class="keywordflow">while</font> (srckv[middex + 1] &lt; midVal)
01247         middex++;
01248       same = 0;
01249     }
01250   
01251   extra = k - same;
01252   *destkv = <font class="keyword">new</font> T[m+k+extra+1];
01253   
01254   <font class="keywordflow">if</font> (same &lt; k)     <font class="comment">/* Must add knots */</font>
01255     {
01256       <font class="keywordflow">for</font> (i = 0; i &lt;= middex; i++)
01257         (*destkv)[i] = srckv[i];
01258       
01259       <font class="keywordflow">for</font> (i = middex+1; i &lt;= middex+extra; i++)
01260         (*destkv)[i] = midVal;
01261       
01262       <font class="keywordflow">for</font> (i = middex + k - same + 1; i &lt;= m + k + extra; i++)
01263         (*destkv)[i] = srckv[i - extra];
01264     }
01265   <font class="keywordflow">else</font>
01266     {
01267       <font class="keywordflow">for</font> (i = 0; i &lt;= m + k; i++)
01268         (*destkv)[i] = srckv[i];
01269     }
01270   
01271   *splitPt = (extra &lt; k) ? middex - 1 : middex;
01272   <font class="keywordflow">return</font>( extra );
01273 }
01274 
01275 <font class="comment">/*</font>
01276 <font class="comment"> * Given a line defined by firstPt and lastPt, project midPt onto</font>
01277 <font class="comment"> * that line.  Used for fixing "cracks".</font>
01278 <font class="comment"> */</font>
01279 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font>
01280 ProjectToLine( Point_nD&lt;T,3&gt; * firstPt, Point_nD&lt;T,3&gt; * lastPt, Point_nD&lt;T,3&gt; * midPt )
01281 {
01282   Point_nD&lt;T,3&gt; base, v0, vm;
01283   T fraction, denom;
01284   
01285   base = *firstPt;
01286   
01287   v0 = *lastPt - base ; <font class="comment">// (void) V3Sub( lastPt, &amp;base, &amp;v0 );</font>
01288   vm = *midPt - base ; <font class="comment">// (void) V3Sub( midPt, &amp;base, &amp;vm );</font>
01289   
01290   denom = norm2(v0) ; <font class="comment">// V3SquaredLength( &amp;v0 );</font>
01291   <font class="comment">//fraction = (denom == 0.0) ? 0.0 : (V3Dot( &amp;v0, &amp;vm ) / denom);</font>
01292   fraction = (denom == 0.0) ? 0.0 : (v0*vm ) / denom;
01293   
01294   midPt-&gt;x() = base.x() + fraction * v0.x();
01295   midPt-&gt;y() = base.y() + fraction * v0.y();
01296   midPt-&gt;z() = base.z() + fraction * v0.z();
01297 }
01298 
01299 <font class="comment">/*</font>
01300 <font class="comment"> * If a normal has collapsed to zero (normLen == 0.0) then try</font>
01301 <font class="comment"> * and fix it by looking at its neighbors.  If all the neighbors</font>
01302 <font class="comment"> * are sick, then re-compute them from the plane they form.</font>
01303 <font class="comment"> * If that fails too, then we give up...</font>
01304 <font class="comment"> */</font>
01305 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font>
01306 FixNormals( SurfSample&lt;T&gt; * s0, SurfSample&lt;T&gt; * s1, SurfSample&lt;T&gt; * s2 )
01307 {
01308   BOOL goodnorm;
01309   <font class="keywordtype">int</font> i, j, ok;
01310   T dist;
01311   SurfSample&lt;T&gt; * V[3];
01312   Point_nD&lt;T,3&gt; normal;
01313   
01314   V[0] = s0; V[1] = s1; V[2] = s2;
01315   
01316   <font class="comment">/* Find a reasonable normalal */</font>
01317   <font class="keywordflow">for</font> (ok = 0, goodnorm = FALSE_;
01318        (ok &lt; 3L) &amp;&amp; !(goodnorm = (V[ok]-&gt;normLen &gt; 0.0)); ok++);
01319   
01320   <font class="keywordflow">if</font> (! goodnorm)       <font class="comment">/* All provided normals are zilch, try and invent one */</font>
01321     {
01322       normal.x() = 0.0; normal.y() = 0.0; normal.z() = 0.0;
01323       
01324       <font class="keywordflow">for</font> (i = 0; i &lt; 3L; i++)
01325         {
01326           j = (i + 1) % 3L;
01327           normal.x() += (V[i]-&gt;point.y() - V[j]-&gt;point.y()) * (V[i]-&gt;point.z() + V[j]-&gt;point.z());
01328           normal.y() += (V[i]-&gt;point.z() - V[j]-&gt;point.z()) * (V[i]-&gt;point.x() + V[j]-&gt;point.x());
01329           normal.z() += (V[i]-&gt;point.x() - V[j]-&gt;point.x()) * (V[i]-&gt;point.y() + V[j]-&gt;point.y());
01330         }
01331       <font class="comment">//dist = V3Length( &amp;norm );</font>
01332       dist = norm(normal) ; 
01333       <font class="keywordflow">if</font> (dist == 0.0)
01334         <font class="keywordflow">return</font>;         <font class="comment">/* This sucker's hopeless... */</font>
01335       
01336       DIVPT( normal, dist );
01337       
01338       <font class="keywordflow">for</font> (i = 0; i &lt; 3; i++)
01339         {
01340           V[i]-&gt;normal = normal;
01341           V[i]-&gt;normLen = dist;
01342         }
01343     }
01344   <font class="keywordflow">else</font>      <font class="comment">/* Replace a sick normal with a healthy one nearby */</font>
01345     {
01346       <font class="keywordflow">for</font> (i = 0; i &lt; 3; i++)
01347         <font class="keywordflow">if</font> ((i != ok) &amp;&amp; (V[i]-&gt;normLen == 0.0))
01348           V[i]-&gt;normal = V[ok]-&gt;normal;
01349     }
01350   <font class="keywordflow">return</font>;
01351 }
01352 
01353 <font class="comment">/*</font>
01354 <font class="comment"> * Normalize the normal in a sample.  If it's degenerate,</font>
01355 <font class="comment"> * flag it as such by setting the normLen to 0.0</font>
01356 <font class="comment"> */</font>
01357 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font>
01358 AdjustNormal( SurfSample&lt;T&gt; * samp )
01359 {
01360   <font class="comment">// If it's not degenerate, do the normalization now */</font>
01361   samp-&gt;normLen = norm(samp-&gt;normal) ; <font class="comment">// V3Length( &amp;(samp-&gt;normal) );</font>
01362 
01363   <font class="keywordflow">if</font> (samp-&gt;normLen &lt; samp-&gt;epsilon )
01364     samp-&gt;normLen = 0.0;
01365   <font class="keywordflow">else</font>
01366     DIVPT( (samp-&gt;normal), samp-&gt;normLen );
01367 }
01368 
01369 <font class="comment">/*</font>
01370 <font class="comment"> * Compute the normal of a corner point of a mesh.  The</font>
01371 <font class="comment"> * base is the value of the point at the corner, indU and indV</font>
01372 <font class="comment"> * are the mesh indices of that point (either 0 or numU|numV).</font>
01373 <font class="comment"> */</font>
01374 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font>
01375 GetNormal( NurbSurface&lt;T&gt; * n, <font class="keywordtype">int</font> indV, <font class="keywordtype">int</font> indU )
01376 {
01377   Point_nD&lt;T,3&gt; tmpL, tmpR;     <font class="comment">/* "Left" and "Right" of the base point */</font>
01378   SurfSample&lt;T&gt; * crnr;
01379   
01380   <font class="keywordflow">if</font> ( (indU &amp;&amp; indV) || ((! indU) &amp;&amp; (!indV)) )
01381     {
01382       <font class="keywordflow">if</font> (indU)
01383         crnr = &amp;(n-&gt;cnn);
01384       <font class="keywordflow">else</font>
01385         crnr = &amp;(n-&gt;c00);
01386       DIVW( &amp;(n-&gt;points(indV,(indU ? (indU-1) : 1))), &amp;tmpL );
01387       DIVW( &amp;(n-&gt;points((indV ? (indV-1) : 1),indU)), &amp;tmpR );
01388     }
01389   <font class="keywordflow">else</font>
01390     {
01391       <font class="keywordflow">if</font> (indU)
01392         crnr = &amp;(n-&gt;c0n);
01393       <font class="keywordflow">else</font>
01394         crnr = &amp;(n-&gt;cn0);
01395       DIVW( &amp;(n-&gt;points(indV,(indU ? (indU-1) : 1))), &amp;tmpR );
01396       DIVW( &amp;(n-&gt;points((indV ? (indV-1) : 1),indU)), &amp;tmpL );
01397     }
01398   
01399   tmpL -= crnr-&gt;point ; <font class="comment">//(void) V3Sub( &amp;tmpL, &amp;(crnr-&gt;point), &amp;tmpL );</font>
01400   tmpR -= crnr-&gt;point ;<font class="comment">//(void) V3Sub( &amp;tmpR, &amp;(crnr-&gt;point), &amp;tmpR );</font>
01401   crnr-&gt;normal = crossProduct(tmpL,tmpR); <font class="comment">//(void) V3Cross( &amp;tmpL, &amp;tmpR, &amp;(crnr-&gt;normal) );</font>
01402   AdjustNormal( crnr );
01403 }
01404 
01405 <font class="comment">/*</font>
01406 <font class="comment"> * Build the new corners in the two new surfaces, computing both</font>
01407 <font class="comment"> * point on the surface aint with the normal.   Prevent cracks that may occur.</font>
01408 <font class="comment"> */</font>
01409 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font>
01410 MakeNewCorners( NurbSurface&lt;T&gt; * parent,
01411                 NurbSurface&lt;T&gt; * kid0,
01412                 NurbSurface&lt;T&gt; * kid1,
01413                 BOOL dirflag )
01414 {
01415   DIVW( &amp;(kid0-&gt;points(maxV(kid0),maxU(kid0))), &amp;(kid0-&gt;cnn.point) );
01416   GetNormal( kid0, maxV(kid0), maxU(kid0) );
01417   
01418   <font class="keywordflow">if</font> (dirflag)
01419     {
01420       kid0-&gt;strUn = FALSE_;     <font class="comment">/* Must re-test new edge straightness */</font>
01421       
01422       DIVW( &amp;(kid0-&gt;points(0,maxU(kid0))), &amp;(kid0-&gt;c0n.point) );
01423       GetNormal( kid0, 0, maxU(kid0) );
01424       <font class="comment">/*</font>
01425 <font class="comment">       * Normals must be re-calculated for kid1 in case the surface</font>
01426 <font class="comment">       * was split at a c1 (or c0!) discontinutiy</font>
01427 <font class="comment">       */</font>
01428       kid1-&gt;c00.point = kid0-&gt;c0n.point;
01429       GetNormal( kid1, 0, 0 );
01430       kid1-&gt;cn0.point = kid0-&gt;cnn.point;
01431       GetNormal( kid1, maxV(kid1), 0 );
01432       
01433       <font class="comment">/*</font>
01434 <font class="comment">       * Prevent cracks from forming by forcing the points on the seam to</font>
01435 <font class="comment">       * lie aint any straight edges.  (Must do this BEFORE finding normals)</font>
01436 <font class="comment">       */</font>
01437       <font class="keywordflow">if</font> (parent-&gt;strV0)
01438         ProjectToLine( &amp;(parent-&gt;c00.point),
01439                        &amp;(parent-&gt;c0n.point),
01440                        &amp;(kid0-&gt;c0n.point) );
01441       <font class="keywordflow">if</font> (parent-&gt;strVn)
01442         ProjectToLine( &amp;(parent-&gt;cn0.point),
01443                        &amp;(parent-&gt;cnn.point),
01444                        &amp;(kid0-&gt;cnn.point) );
01445       
01446       kid1-&gt;c00.point = kid0-&gt;c0n.point;
01447       kid1-&gt;cn0.point = kid0-&gt;cnn.point;
01448       kid1-&gt;strU0 = FALSE_;
01449     }
01450   <font class="keywordflow">else</font>
01451     {
01452       kid0-&gt;strVn = FALSE_;
01453       
01454       DIVW( &amp;(kid0-&gt;points(maxV(kid0),0)), &amp;(kid0-&gt;cn0.point) );
01455       GetNormal( kid0, maxV(kid0), 0 );
01456       kid1-&gt;c00.point = kid0-&gt;cn0.point;
01457       GetNormal( kid1, 0, 0 );
01458       kid1-&gt;c0n.point = kid0-&gt;cnn.point;
01459       GetNormal( kid1, 0, maxU(kid1) );
01460       
01461       <font class="keywordflow">if</font> (parent-&gt;strU0)
01462         ProjectToLine( &amp;(parent-&gt;c00.point),
01463                        &amp;(parent-&gt;cn0.point),
01464                        &amp;(kid0-&gt;cn0.point) );
01465       <font class="keywordflow">if</font> (parent-&gt;strUn)
01466         ProjectToLine( &amp;(parent-&gt;c0n.point),
01467                        &amp;(parent-&gt;cnn.point),
01468                        &amp;(kid0-&gt;cnn.point) );
01469       
01470       kid1-&gt;c00.point = kid0-&gt;cn0.point;
01471       kid1-&gt;c0n.point = kid0-&gt;cnn.point;
01472       kid1-&gt;strV0 = FALSE_;
01473     }
01474 }
01475 
01476 <font class="comment">/*</font>
01477 <font class="comment"> * Split a surface into two halves.  First inserts multiplicity k knots</font>
01478 <font class="comment"> * in the center of the parametric range.  After refinement, the two</font>
01479 <font class="comment"> * resulting surfaces are copied into separate data structures.  If the</font>
01480 <font class="comment"> * parent surface had straight edges, the points of the children are</font>
01481 <font class="comment"> * projected onto those edges.</font>
01482 <font class="comment"> */</font>
01483 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font>
01484 SplitSurface( NurbSurface&lt;T&gt; * parent,
01485               NurbSurface&lt;T&gt; * kid0, NurbSurface&lt;T&gt; * kid1,
01486               BOOL dirflag )        <font class="comment">/* If TRUE_ subdivided in U, else in V */</font>
01487 {
01488   NurbSurface&lt;T&gt; *tmp;
01489   T * newkv;
01490   <font class="keywordtype">int</font> i, j, splitPt;
01491   
01492   tmp = <font class="keyword">new</font> NurbSurface&lt;T&gt; ;
01493 
01494   <font class="comment">//</font>
01495   <font class="comment">// Add a multiplicty k knot to the knot vector in the direction</font>
01496   <font class="comment">// specified by dirflag, and refine the surface.  This creates two</font>
01497   <font class="comment">// adjacent surfaces with c0 discontinuity at the seam.</font>
01498   <font class="comment">//</font>
01499 
01500   <font class="comment">//tmp = *parent;      // Copy order, # of points, etc. </font>
01501   tmp-&gt;numU = parent-&gt;numU ;
01502   tmp-&gt;numV = parent-&gt;numV ;
01503   tmp-&gt;orderU = parent-&gt;orderU ;
01504   tmp-&gt;orderV = parent-&gt;orderV ;
01505   
01506   tmp-&gt;strU0 = parent-&gt;strU0 ; 
01507   tmp-&gt;strUn = parent-&gt;strUn ; 
01508   tmp-&gt;strV0 = parent-&gt;strV0 ; 
01509   tmp-&gt;strVn = parent-&gt;strVn ; 
01510   
01511   tmp-&gt;render = parent-&gt;render ; 
01512   
01513   <font class="keywordflow">if</font> (dirflag)
01514     {
01515       tmp-&gt;numU = parent-&gt;numU + SplitKV( parent-&gt;kvU,
01516                                          &amp;newkv,
01517                                          &amp;splitPt,
01518                                          maxU(parent),
01519                                          parent-&gt;orderU );
01520       AllocNurb( tmp, newkv, (T*)0 );
01521       <font class="keywordflow">for</font> (i = 0; i &lt; tmp-&gt;numV + tmp-&gt;orderV; i++)
01522         tmp-&gt;kvV[i] = parent-&gt;kvV[i];
01523     }
01524   <font class="keywordflow">else</font>
01525     {
01526       tmp-&gt;numV = parent-&gt;numV + SplitKV( parent-&gt;kvV,
01527                                          &amp;newkv,
01528                                          &amp;splitPt,
01529                                          maxV(parent),
01530                                          parent-&gt;orderV );
01531       AllocNurb( tmp, (T*)0, newkv );
01532       <font class="keywordflow">for</font> (i = 0; i &lt; tmp-&gt;numU + tmp-&gt;orderU; i++)
01533         tmp-&gt;kvU[i] = parent-&gt;kvU[i];
01534     }
01535   RefineSurface( parent, tmp, dirflag );
01536   
01537   <font class="comment">//</font>
01538   <font class="comment">// Build the two child surfaces, and copy the data from the refined</font>
01539   <font class="comment">// version of the parent (tmp) into the two children</font>
01540   <font class="comment">//</font>
01541 
01542   <font class="comment">// First half </font>
01543   
01544   <font class="comment">//    *kid0 = *parent;        // copy various edge flags and orders </font>
01545   kid0-&gt;orderU = parent-&gt;orderU ;
01546   kid0-&gt;orderV = parent-&gt;orderV ;
01547   
01548   kid0-&gt;strU0 = parent-&gt;strU0 ; 
01549   kid0-&gt;strUn = parent-&gt;strUn ; 
01550   kid0-&gt;strV0 = parent-&gt;strV0 ; 
01551   kid0-&gt;strVn = parent-&gt;strVn ; 
01552   
01553   kid0-&gt;c00 = parent-&gt;c00 ;
01554   kid0-&gt;c0n = parent-&gt;c0n ;
01555   kid0-&gt;cn0 = parent-&gt;cn0 ;
01556   kid0-&gt;cnn = parent-&gt;cnn ;
01557   
01558   kid0-&gt;render = parent-&gt;render ; 
01559   
01560   kid0-&gt;numU = dirflag ? splitPt+1 : parent-&gt;numU;
01561   kid0-&gt;numV = dirflag ? parent-&gt;numV : splitPt+1;
01562   kid0-&gt;kvU = kid0-&gt;kvV = 0;
01563   AllocNurb( kid0, (T*)0, (T*)0 );
01564   
01565   <font class="keywordflow">for</font> (i = 0; i &lt; kid0-&gt;numV; i++)      <font class="comment">// Copy the point and kv data </font>
01566     <font class="keywordflow">for</font> (j = 0; j &lt; kid0-&gt;numU; j++)
01567       kid0-&gt;points(i,j) = tmp-&gt;points(i,j) ;
01568   <font class="keywordflow">for</font> (i = 0; i &lt; kid0-&gt;orderU + kid0-&gt;numU; i++)
01569     kid0-&gt;kvU[i] = tmp-&gt;kvU[i];
01570   <font class="keywordflow">for</font> (i = 0; i &lt; kid0-&gt;orderV + kid0-&gt;numV; i++)
01571     kid0-&gt;kvV[i] = tmp-&gt;kvV[i];
01572   
01573   <font class="comment">// Second half </font>
01574   
01575   splitPt++;
01576   <font class="comment">//*kid1 = *parent;</font>
01577   kid1-&gt;orderU = parent-&gt;orderU ;
01578   kid1-&gt;orderV = parent-&gt;orderV ;
01579   
01580   kid1-&gt;strU0 = parent-&gt;strU0 ; 
01581   kid1-&gt;strUn = parent-&gt;strUn ; 
01582   kid1-&gt;strV0 = parent-&gt;strV0 ; 
01583   kid1-&gt;strVn = parent-&gt;strVn ; 
01584 
01585   kid1-&gt;c00 = parent-&gt;c00 ;
01586   kid1-&gt;c0n = parent-&gt;c0n ;
01587   kid1-&gt;cn0 = parent-&gt;cn0 ;
01588   kid1-&gt;cnn = parent-&gt;cnn ;
01589   
01590   kid1-&gt;render = parent-&gt;render ; 
01591   
01592   kid1-&gt;numU = dirflag ? tmp-&gt;numU - splitPt : parent-&gt;numU;
01593   kid1-&gt;numV = dirflag ? parent-&gt;numV : tmp-&gt;numV - splitPt;
01594   kid1-&gt;kvU = kid1-&gt;kvV = 0;
01595   AllocNurb( kid1, (T*)0, (T*)0 );
01596   
01597   <font class="keywordflow">for</font> (i = 0; i &lt; kid1-&gt;numV; i++)      <font class="comment">// Copy the point and kv data </font>
01598     <font class="keywordflow">for</font> (j = 0; j &lt; kid1-&gt;numU; j++)
01599       kid1-&gt;points(i,j)
01600         = tmp-&gt;points(dirflag ? i: (i + splitPt) ,dirflag ? (j + splitPt) : j);
01601   <font class="keywordflow">for</font> (i = 0; i &lt; kid1-&gt;orderU + kid1-&gt;numU; i++)
01602     kid1-&gt;kvU[i] = tmp-&gt;kvU[dirflag ? (i + splitPt) : i];
01603   <font class="keywordflow">for</font> (i = 0; i &lt; kid1-&gt;orderV + kid1-&gt;numV; i++)
01604     kid1-&gt;kvV[i] = tmp-&gt;kvV[dirflag ? i : (i + splitPt)];
01605     
01606   <font class="comment">// Construct new corners on the boundry between the two kids </font>
01607   MakeNewCorners( parent, kid0, kid1, dirflag );
01608   
01609   FreeNurb( tmp );          <font class="comment">// Get rid of refined parent </font>
01610     
01611 }
01612 
01613 <font class="comment">/*</font>
01614 <font class="comment"> * Test if a particular row or column of control points in a mesh</font>
01615 <font class="comment"> * is "straight" with respect to a particular tolerance.  Returns TRUE_</font>
01616 <font class="comment"> * if it is.</font>
01617 <font class="comment"> */</font>
01618 
01619 <font class="preprocessor">#define GETPT( i )  (( dirflag ? (n-&gt;points(crvInd,i)) : (n-&gt;points(i,crvInd)) ))</font>
01620 <font class="preprocessor"></font>
01621 <font class="preprocessor">#define EPSILON n-&gt;epsilon</font>
01622 <font class="preprocessor"></font>
01623 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; BOOL
01624 IsCurveStraight( NurbSurface&lt;T&gt; * n,
01625                  T tolerance,
01626                  <font class="keywordtype">int</font> crvInd,
01627                  BOOL dirflag )  <font class="comment">/* If TRUE_, test in U direction, else test in V */</font>
01628 {
01629   Point_nD&lt;T,3&gt; p, vec, prod;
01630   Point_nD&lt;T,3&gt; cp, e0;
01631   <font class="keywordtype">int</font> i, last;
01632   T linelen, dist;
01633   
01634   <font class="comment">/* Special case: lines are automatically straight. */</font>
01635   <font class="keywordflow">if</font> ((dirflag ? n-&gt;numU : n-&gt;numV) == 2)
01636     <font class="keywordflow">return</font>( TRUE_ );
01637   
01638   last = (dirflag ? n-&gt;numU : n-&gt;numV) - 1;
01639   n-&gt;render-&gt;screenProject( GETPT( 0 ), e0 );
01640   
01641   <font class="comment">/* Form an initial line to test the other points against (skiping degen lines) */</font>
01642   
01643   linelen = 0.0;
01644   <font class="keywordflow">for</font> (i = last; (i &gt; 0) &amp;&amp; (linelen &lt; EPSILON); i--)
01645     {
01646       n-&gt;render-&gt;screenProject( GETPT( i ), cp );
01647       vec = cp - e0 ; 
01648       linelen = norm(vec) ;
01649     }
01650   
01651   DIVPT( vec, linelen );
01652 
01653   <font class="keywordflow">if</font> (linelen &gt; EPSILON)        <font class="comment">/* If no non-degenerate lines found, it's all degen */</font>
01654     <font class="keywordflow">for</font> (i = 1; i &lt;= last; i++)
01655       {
01656         <font class="comment">/* The cross product of the vector defining the</font>
01657 <font class="comment">         * initial line with the vector of the current point</font>
01658 <font class="comment">         * gives the distance to the line. */</font>
01659         n-&gt;render-&gt;screenProject( GETPT( i ), cp );
01660         p = cp - e0 ; 
01661         
01662         prod = crossProduct(p,vec) ; 
01663         dist = norm(prod) ; 
01664         
01665         <font class="keywordflow">if</font> (dist &gt; tolerance)
01666           <font class="keywordflow">return</font>( FALSE_ );
01667       }
01668   
01669   <font class="keywordflow">return</font>( TRUE_ );
01670 }
01671 
01672 <font class="comment">/*</font>
01673 <font class="comment"> * Check to see if a surface is flat.  Tests are only performed on edges and</font>
01674 <font class="comment"> * directions that aren't already straight.  If an edge is flagged as straight</font>
01675 <font class="comment"> * (from the parent surface) it is assumed it will stay that way.</font>
01676 <font class="comment"> */</font>
01677 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; BOOL
01678 TestFlat( NurbSurface&lt;T&gt; * n, T tolerance )
01679 {
01680   <font class="keywordtype">int</font> i;
01681   BOOL straight;
01682   Point_nD&lt;T,3&gt; cp00, cp0n, cpn0, cpnn, planeEqn;
01683   T dist,d ;
01684   
01685   <font class="comment">/* Check edge straightness */</font>
01686   
01687   <font class="keywordflow">if</font> (! n-&gt;strU0)
01688     n-&gt;strU0 = IsCurveStraight( n, tolerance, 0, FALSE_ );
01689   <font class="keywordflow">if</font> (! n-&gt;strUn)
01690     n-&gt;strUn = IsCurveStraight( n, tolerance, maxU(n), FALSE_ );
01691   <font class="keywordflow">if</font> (! n-&gt;strV0)
01692     n-&gt;strV0 = IsCurveStraight( n, tolerance, 0, TRUE_ );
01693   <font class="keywordflow">if</font> (! n-&gt;strVn)
01694     n-&gt;strVn = IsCurveStraight( n, tolerance, maxV(n), TRUE_ );
01695   
01696   <font class="comment">/* Test to make sure control points are straight in U and V */</font>
01697   
01698   straight = TRUE_;
01699   <font class="keywordflow">if</font> ( (! n-&gt;flatU) &amp;&amp; (n-&gt;strV0) &amp;&amp; (n-&gt;strVn) )
01700     <font class="keywordflow">for</font> (i = 1;
01701          (i &lt; maxV(n)) &amp;&amp; (straight = IsCurveStraight( n, tolerance, i, TRUE_ ));
01702          i++);
01703   
01704   <font class="keywordflow">if</font> (straight &amp;&amp; n-&gt;strV0 &amp;&amp; n-&gt;strVn)
01705     n-&gt;flatU = TRUE_;
01706   
01707   straight = TRUE_;
01708   <font class="keywordflow">if</font> ( (! n-&gt;flatV) &amp;&amp; (n-&gt;strU0) &amp;&amp; (n-&gt;strUn) )
01709     <font class="keywordflow">for</font> (i = 1;
01710          (i &lt; maxU(n)) &amp;&amp; (straight = IsCurveStraight( n, tolerance, i, FALSE_ ));
01711          i++);
01712   
01713   <font class="keywordflow">if</font> (straight &amp;&amp; n-&gt;strU0 &amp;&amp; n-&gt;strUn)
01714     n-&gt;flatV = TRUE_;
01715   
01716   <font class="keywordflow">if</font> ( (! n-&gt;flatV) || (! n-&gt;flatU) )
01717     <font class="keywordflow">return</font>( FALSE_ );
01718   
01719   <font class="comment">// The surface can pass the above tests but still be twisted. </font>
01720   
01721   n-&gt;render-&gt;screenProject( (n-&gt;points(0,0)),       cp00 );
01722   n-&gt;render-&gt;screenProject( (n-&gt;points(0,maxU(n))),         cp0n );
01723   n-&gt;render-&gt;screenProject( (n-&gt;points(maxV(n),0)),         cpn0 );
01724   n-&gt;render-&gt;screenProject( (n-&gt;points(maxV(n),maxU(n))),  cpnn );
01725   
01726   cp0n -= cp00 ; <font class="comment">// Make edges into vectors</font>
01727   cpn0 -= cp00 ; 
01728   
01729   
01730   <font class="comment">// Compute the plane equation from two adjacent sides, and</font>
01731   <font class="comment">// measure the distance from the far point to the plane.  If it's</font>
01732   <font class="comment">// larger than tolerance, the surface is twisted.</font>
01733   
01734   planeEqn = crossProduct(cpn0,cp0n) ; 
01735   planeEqn = planeEqn.unitLength() ; <font class="comment">// Normalize to keep adds in sync w/ mults </font>
01736   
01737   d = planeEqn * cp00 ; 
01738   dist = fabs( ( planeEqn * cpnn ) - d );
01739   
01740   <font class="keywordflow">if</font> ( dist &gt; tolerance ) <font class="comment">// Surface is twisted </font>
01741     <font class="keywordflow">return</font>( FALSE_ );
01742   <font class="keywordflow">else</font>
01743     <font class="keywordflow">return</font>( TRUE_ );
01744 }
01745 
01746 <font class="comment">/*</font>
01747 <font class="comment"> * Turn a sufficiently flat surface into triangles.</font>
01748 <font class="comment"> */</font>
01749 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; 
01750 <font class="keywordtype">void</font> EmitTriangles( NurbSurface&lt;T&gt; * n )
01751 {
01752   Point_nD&lt;T,3&gt; vecnn, vec0n;   <font class="comment">// Diagonal vectors </font>
01753   T len2nn, len20n;             <font class="comment">// Diagonal lengths squared </font>
01754   T u0, un, v0, vn;             <font class="comment">// Texture coords;</font>
01755                                    
01756   <font class="comment">//</font>
01757   <font class="comment">// Measure the distance aint the two diagonals to decide the best</font>
01758   <font class="comment">// way to cut the rectangle into triangles.</font>
01759   <font class="comment">//</font>
01760   
01761   vecnn = n-&gt;c00.point - n-&gt;cnn.point ; 
01762   vec0n = n-&gt;c0n.point - n-&gt;cn0.point ; 
01763   
01764   len2nn = norm2(vecnn) ; 
01765   len20n = norm2(vec0n) ; 
01766   
01767   <font class="keywordflow">if</font> (maximum(len2nn, len20n) &lt; n-&gt;epsilon)
01768     <font class="keywordflow">return</font>;                             <font class="comment">// Triangles are too small to render </font>
01769   
01770   <font class="comment">//</font>
01771   <font class="comment">// Assign the texture coordinates</font>
01772   <font class="comment">//</font>
01773   u0 = n-&gt;kvU[n-&gt;orderU-1];
01774   un = n-&gt;kvU[n-&gt;numU];
01775   v0 = n-&gt;kvV[n-&gt;orderV-1];
01776   vn = n-&gt;kvV[n-&gt;numV];
01777   n-&gt;c00.u = u0; n-&gt;c00.v = v0;
01778   n-&gt;c0n.u = un; n-&gt;c0n.v = v0;
01779   n-&gt;cn0.u = u0; n-&gt;cn0.v = vn;
01780   n-&gt;cnn.u = un; n-&gt;cnn.v = vn;
01781   
01782   <font class="comment">//</font>
01783   <font class="comment">// If any normals are sick, fix them now.</font>
01784   <font class="comment">//</font>
01785   <font class="keywordflow">if</font> ((n-&gt;c00.normLen == 0.0) || (n-&gt;cnn.normLen == 0.0) || (n-&gt;cn0.normLen == 0.0))
01786     FixNormals( &amp;(n-&gt;c00), &amp;(n-&gt;cnn), &amp;(n-&gt;cn0) );
01787   <font class="keywordflow">if</font> (n-&gt;c0n.normLen == 0.0)
01788     FixNormals( &amp;(n-&gt;c00), &amp;(n-&gt;c0n), &amp;(n-&gt;cnn) );
01789   
01790   <font class="keywordflow">if</font> ( len2nn &lt; len20n )
01791     {
01792       n-&gt;render-&gt;drawTriangle( n-&gt;c00, n-&gt;cnn, n-&gt;cn0 );
01793       n-&gt;render-&gt;drawTriangle( n-&gt;c00, n-&gt;c0n, n-&gt;cnn );
01794     }                                            
01795   <font class="keywordflow">else</font>                                   
01796     {                                            
01797       n-&gt;render-&gt;drawTriangle( n-&gt;c0n, n-&gt;cnn, n-&gt;cn0 );
01798       n-&gt;render-&gt;drawTriangle( n-&gt;c0n, n-&gt;cn0, n-&gt;c00 );
01799     }
01800 }
01801 
01802 <font class="comment">/*</font>
01803 <font class="comment"> * The recursive subdivision algorithm.  Test if the surface is flat.</font>
01804 <font class="comment"> * If so, split it into triangles.  Otherwise, split it into two halves,</font>
01805 <font class="comment"> * and invoke the procedure on each half.</font>
01806 <font class="comment"> */</font>
01807 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font>
01808 DoSubdivision( NurbSurface&lt;T&gt; * n, T tolerance, BOOL dirflag, <font class="keywordtype">int</font> level )
01809 {
01810   NurbSurface&lt;T&gt; *left, *right;
01811   
01812   left = <font class="keyword">new</font> NurbSurface&lt;T&gt;;
01813   right = <font class="keyword">new</font> NurbSurface&lt;T&gt;;
01814 
01815   <font class="keywordflow">if</font> (TestFlat( n, tolerance ))
01816     {
01817       EmitTriangles( n );
01818     }
01819   <font class="keywordflow">else</font>
01820     {
01821       <font class="keywordflow">if</font> ( ((! n-&gt;flatV) &amp;&amp; (! n-&gt;flatU)) || ((n-&gt;flatV) &amp;&amp; (n-&gt;flatU)) )
01822         dirflag = !dirflag;    <font class="comment">// If twisted or curved in both directions, </font>
01823       <font class="keywordflow">else</font>                     <font class="comment">// then alternate subdivision direction </font>
01824         {
01825           <font class="keywordflow">if</font> (n-&gt;flatU)        <font class="comment">// Only split in directions that aren't flat </font>
01826             dirflag = FALSE_;
01827           <font class="keywordflow">else</font>
01828             dirflag = TRUE_;
01829         }
01830       SplitSurface( n, left, right, dirflag );
01831       DoSubdivision( left, tolerance, dirflag, level + 1 );
01832       DoSubdivision( right, tolerance, dirflag, level + 1 );
01833       FreeNurb( left );
01834       FreeNurb( right );
01835     }
01836 }
01837 
01838 <font class="comment">/*</font>
01839 <font class="comment"> * Main entry point for subdivision */</font>
01840 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt; <font class="keywordtype">void</font>
01841 DrawSubdivision( NurbSurface&lt;T&gt; * surf, T tolerance )
01842 {
01843   surf-&gt;flatV = FALSE_;
01844   surf-&gt;flatU = FALSE_;
01845   surf-&gt;strU0 = FALSE_;
01846   surf-&gt;strUn = FALSE_;
01847   surf-&gt;strV0 = FALSE_;
01848   surf-&gt;strVn = FALSE_;
01849   
01850   <font class="comment">//</font>
01851   <font class="comment">// Initialize the projected corners of the surface</font>
01852   <font class="comment">// and the normals.</font>
01853   <font class="comment">//</font>
01854   DIVW( &amp;(surf-&gt;points(0,0)), &amp;surf-&gt;c00.point );
01855   DIVW( &amp;(surf-&gt;points(0,surf-&gt;numU-1)), &amp;surf-&gt;c0n.point );
01856   DIVW( &amp;(surf-&gt;points(surf-&gt;numV-1,0)), &amp;surf-&gt;cn0.point );
01857   DIVW( &amp;(surf-&gt;points(surf-&gt;numV-1,surf-&gt;numU-1)), &amp;surf-&gt;cnn.point );
01858 
01859   GetNormal( surf, 0, 0 );
01860   GetNormal( surf, 0, maxU(surf) );
01861   GetNormal( surf, maxV(surf), 0 );
01862   GetNormal( surf, maxV(surf), maxU(surf) );
01863   
01864   RenderMesh&lt;T&gt; *render ;
01865 
01866   render = surf-&gt;render ;
01867   render-&gt;drawHeader();
01868   DoSubdivision( surf, tolerance, TRUE_, 0 );
01869   <font class="comment">// Note surf is deallocated by the subdivision process </font>
01870   render-&gt;drawFooter();
01871 }
01872 
01881 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T&gt;
<a name="l01882"></a><a class="code" href="classPLib_1_1SurfSample.html#a0" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1SurfSample.html#a0">01882</a> SurfSample&lt;T&gt;&amp; SurfSample&lt;T&gt;::operator=(<font class="keyword">const</font> SurfSample&lt;T&gt;&amp; s) {
01883   <a class="code" href="classPLib_1_1SurfSample.html#m0" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1SurfSample.html#m0">point</a> = s.point ;
01884   <a class="code" href="classPLib_1_1SurfSample.html#m1" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1SurfSample.html#m1">normal</a> = s.normal ;
01885   <a class="code" href="classPLib_1_1SurfSample.html#m2" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1SurfSample.html#m2">normLen</a> = s.normLen ;
01886   u = s.u ;
01887   <a class="code" href="classPLib_1_1SurfSample.html#m4" tppabs="http://libnurbs.sourceforge.net/docs/classPLib_1_1SurfSample.html#m4">v</a> = s.v ;
01888   <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
01889 }
01890 
01891 <font class="comment">/*</font>
01892 <font class="comment">template &lt;class T&gt;</font>
01893 <font class="comment">class NurbsCurveTess : public NurbsCurve&lt;T,2&gt; {</font>
01894 <font class="comment">public:</font>
01895 <font class="comment">  NurbsCurveTess(const NurbsSurface&lt;T,3&gt;&amp; rs) ;</font>
01896 <font class="comment"></font>
01897 <font class="comment">  void tesselate(T tol) ; </font>
01898 <font class="comment"></font>
01899 <font class="comment">protected:</font>
01900 <font class="comment">  int isStraight() ; </font>
01901 <font class="comment"></font>
01902 <font class="comment">  const NurbsSurface&lt;T,3&gt;&amp; rsurf ; </font>
01903 <font class="comment">  T tolerance ; </font>
01904 <font class="comment">}</font>
01905 <font class="comment"></font>
01906 <font class="comment">template &lt;class T&gt;</font>
01907 <font class="comment">NurbsCurveTess::NurbsCurveTess(const NurbsSurface&lt;T,3&gt;&amp; rs) : rsurf(rs) {</font>
01908 <font class="comment">  tolerance = 0.01 ; </font>
01909 <font class="comment">}</font>
01910 <font class="comment"></font>
01911 <font class="comment">template &lt;class T&gt;</font>
01912 <font class="comment">void NurbsCurveTess::tesselate(T tol){</font>
01913 <font class="comment">  tolerance = tol ; </font>
01914 <font class="comment">  if(knot.n() != 2*(deg_+1)){</font>
01915 <font class="comment">    </font>
01916 <font class="comment">  }</font>
01917 <font class="comment">}</font>
01918 <font class="comment">*/</font>
01919 
01920 }
01921 
01922 <font class="preprocessor">#endif // #define PLIB_NURBS_NURBSSUB_SOURCE</font>
</pre></div><hr><address><small>Generated on Tue Jun 24 13:26:58 2003 for NURBS++ by
<a href="javascript:if(confirm('http://www.doxygen.org/index.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.doxygen.org/index.html'" tppabs="http://www.doxygen.org/index.html">
<img src="doxygen.gif" tppabs="http://libnurbs.sourceforge.net/docs/doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.14 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2002</small></address>
</body>
</html>
