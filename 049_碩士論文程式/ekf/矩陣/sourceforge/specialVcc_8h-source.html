<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>specialVcc.h Source File</title>
<link href="doxygen.css" tppabs="http://libnurbs.sourceforge.net/docs/doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.14 -->
<center>
<a class="qindex" href="index.html" tppabs="http://libnurbs.sourceforge.net/docs/index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html" tppabs="http://libnurbs.sourceforge.net/docs/hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html" tppabs="http://libnurbs.sourceforge.net/docs/annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html" tppabs="http://libnurbs.sourceforge.net/docs/files.html">File List</a> &nbsp; <a class="qindex" href="functions.html" tppabs="http://libnurbs.sourceforge.net/docs/functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>specialVcc.h</h1><div class="fragment"><pre>00001 <font class="comment">/*============================================================================</font>
00002 <font class="comment">        File: specialVcc.h</font>
00003 <font class="comment">     Purpose: Hides some of the hugly things we have to do to make VC++ happy</font>
00004 <font class="comment">              when compiling.</font>
00005 <font class="comment">    Revision: $Id: specialVcc.h,v 1.2 2002/05/13 21:07:45 philosophil Exp $</font>
00006 <font class="comment">  author Philippe Lavoie          (3 Oct, 1996)</font>
00007 <font class="comment"> Modified by: </font>
00008 <font class="comment"></font>
00009 <font class="comment"> Copyright notice:</font>
00010 <font class="comment">          Copyright (C) 1996-1997 Philippe Lavoie</font>
00011 <font class="comment"> </font>
00012 <font class="comment">          This library is free software; you can redistribute it and/or</font>
00013 <font class="comment">          modify it under the terms of the GNU Library General Public</font>
00014 <font class="comment">          License as published by the Free Software Foundation; either</font>
00015 <font class="comment">          version 2 of the License, or (at your option) any later version.</font>
00016 <font class="comment"> </font>
00017 <font class="comment">          This library is distributed in the hope that it will be useful,</font>
00018 <font class="comment">          but WITHOUT ANY WARRANTY; without even the implied warranty of</font>
00019 <font class="comment">          MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
00020 <font class="comment">          Library General Public License for more details.</font>
00021 <font class="comment"> </font>
00022 <font class="comment">          You should have received a copy of the GNU Library General Public</font>
00023 <font class="comment">          License along with this library; if not, write to the Free</font>
00024 <font class="comment">          Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</font>
00025 <font class="comment">=============================================================================*/</font>
00026 <font class="preprocessor">#ifndef _Matrix_specialVcc_h_</font>
00027 <font class="preprocessor"></font><font class="preprocessor">#define _Matrix_specialVcc_h_</font>
00028 <font class="preprocessor"></font>
00029 
00030 <font class="keyword">template</font> &lt;<font class="keyword">class</font> T,<font class="keywordtype">int</font> N&gt; 
00031 <font class="keywordtype">double</font> norm(<font class="keyword">const</font> Point_nD&lt;T,N&gt;&amp; a);
00032 
00033 
00034 <font class="keyword">template</font>&lt;&gt;
00035 <font class="keyword">struct </font>Point_nD&lt;float,3&gt; { 
00036   <font class="keyword">typedef</font> <font class="keywordtype">float</font> T;
00037   T data[3] ;
00038   Point_nD()  { x() = y() = z() = 0 ;}
00039   Point_nD(T a)  { x() = y() = z() = a ;}
00040   Point_nD(T X, T Y, T Z)  {x()=X ; y()=Y ; z()=Z ;}
00041   Point_nD(<font class="keyword">const</font> Point_nD&lt;float,3&gt;&amp; a)  { memcpy((<font class="keywordtype">void</font>*)data,(<font class="keywordtype">void</font>*)a.data,3*<font class="keyword">sizeof</font>(T));}
00042 
00043   <font class="keyword">inline</font> T&amp; x() { <font class="keywordflow">return</font> data[0] ; }
00044   <font class="keyword">inline</font> T&amp; y() { <font class="keywordflow">return</font> data[1] ; }
00045   <font class="keyword">inline</font> T&amp; z() { <font class="keywordflow">return</font> data[2] ; }
00046   <font class="keyword">inline</font> T x()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[0] ; }
00047   <font class="keyword">inline</font> T y()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[1] ; }
00048   <font class="keyword">inline</font> T z()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[2] ; }
00049 
00050   Point_nD&amp; operator=(<font class="keyword">const</font> Point_nD&amp; v) { x()=v.x() ; y()=v.y() ; z()=v.z() ;  <font class="keywordflow">return</font> *<font class="keyword">this</font> ;} ;
00051   Point_nD&amp; operator+=(<font class="keyword">const</font> Point_nD&amp; v) {x()+=v.x() ; y()+= v.y() ; z()+=v.z() ;  <font class="keywordflow">return</font> *<font class="keyword">this</font>;} ;
00052   Point_nD&amp; operator-=(<font class="keyword">const</font> Point_nD&amp; v) {x()-=v.x() ; y()-= v.y() ; z()-=v.z() ;  <font class="keywordflow">return</font> *<font class="keyword">this</font>;} ;
00053   Point_nD&amp; operator*=(T v) {x()*=v ; y()*= v ; z()*= v;  <font class="keywordflow">return</font> *<font class="keyword">this</font>;} ;
00054   Point_nD&amp; operator/=(T v) {x()/=v ; y()/= v ; z()/= v ; <font class="keywordflow">return</font> *<font class="keyword">this</font>;} ;
00055  
00056   Point_nD unitLength()<font class="keyword"> const </font>{
00057         T d = norm(*<font class="keyword">this</font>) ;
00058     Point_nD&lt;T,3&gt; u(x()/d,y()/d,z()/d) ;
00059     <font class="keywordflow">return</font> u ;
00060   }
00061 };
00062 
00063 <font class="keyword">template</font>&lt;&gt;
00064 <font class="keyword">struct </font>Point_nD&lt;double,3&gt; { 
00065   <font class="keyword">typedef</font> <font class="keywordtype">double</font> T;
00066   T data[3] ;
00067   Point_nD()  { x() = y() = z() = 0 ;}
00068   Point_nD(T a)  { x() = y() = z() = a ;}
00069   Point_nD(T X, T Y, T Z)  {x()=X ; y()=Y ; z()=Z ;}
00070   Point_nD(<font class="keyword">const</font> Point_nD&lt;float,3&gt;&amp; a)  { memcpy((<font class="keywordtype">void</font>*)data,(<font class="keywordtype">void</font>*)a.data,3*<font class="keyword">sizeof</font>(T));}
00071 
00072   <font class="keyword">inline</font> T&amp; x() { <font class="keywordflow">return</font> data[0] ; }
00073   <font class="keyword">inline</font> T&amp; y() { <font class="keywordflow">return</font> data[1] ; }
00074   <font class="keyword">inline</font> T&amp; z() { <font class="keywordflow">return</font> data[2] ; }
00075   <font class="keyword">inline</font> T x()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[0] ; }
00076   <font class="keyword">inline</font> T y()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[1] ; }
00077   <font class="keyword">inline</font> T z()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[2] ; }
00078 
00079   Point_nD&amp; operator=(<font class="keyword">const</font> Point_nD&amp; v) { x()=v.x() ; y()=v.y() ; z()=v.z() ;  <font class="keywordflow">return</font> *<font class="keyword">this</font> ;} ;
00080   Point_nD&amp; operator+=(<font class="keyword">const</font> Point_nD&amp; v) {x()+=v.x() ; y()+= v.y() ; z()+=v.z() ;  <font class="keywordflow">return</font> *<font class="keyword">this</font>;} ;
00081   Point_nD&amp; operator-=(<font class="keyword">const</font> Point_nD&amp; v) {x()-=v.x() ; y()-= v.y() ; z()-=v.z() ;  <font class="keywordflow">return</font> *<font class="keyword">this</font>;} ;
00082   Point_nD&amp; operator*=(T v) {x()*=v ; y()*= v ; z()*= v;  <font class="keywordflow">return</font> *<font class="keyword">this</font>;} ;
00083   Point_nD&amp; operator/=(T v) {x()/=v ; y()/= v ; z()/= v ; <font class="keywordflow">return</font> *<font class="keyword">this</font>;} ;
00084  
00085   Point_nD unitLength()<font class="keyword"> const </font>{
00086         T d = norm(*<font class="keyword">this</font>) ;
00087     Point_nD&lt;T,3&gt; u(x()/d,y()/d,z()/d) ;
00088     <font class="keywordflow">return</font> u ;
00089   }
00090 };
00091 
00092 
00093 <font class="keyword">template</font>&lt;&gt;
00094 <font class="keyword">struct </font>Point_nD&lt;float,2&gt; { 
00095   <font class="keyword">typedef</font> <font class="keywordtype">float</font> T;
00096   T data[2] ;
00097   Point_nD()  { x() = y() = 0 ;}
00098   Point_nD(T a)  { x() = y() = a ;}
00099   Point_nD(T X, T Y)  {x()=X ; y()=Y ; }
00100   Point_nD(<font class="keyword">const</font> Point_nD&lt;T,2&gt;&amp; a)  { memcpy((<font class="keywordtype">void</font>*)data,(<font class="keywordtype">void</font>*)a.data,2*<font class="keyword">sizeof</font>(T));}
00101 
00102   <font class="keyword">inline</font> T&amp; x() { <font class="keywordflow">return</font> data[0] ; }
00103   <font class="keyword">inline</font> T&amp; y() { <font class="keywordflow">return</font> data[1] ; }
00104   <font class="keyword">inline</font> T&amp; z() { <font class="keywordflow">return</font> dumbVar ; }
00105   <font class="keyword">inline</font> T x()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[0] ; }
00106   <font class="keyword">inline</font> T y()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[1] ; }
00107   <font class="keyword">inline</font> T z()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> T() ; }
00108  
00109   Point_nD&amp; operator=(<font class="keyword">const</font> Point_nD&amp; v) { x()=v.x() ; y()=v.y() ; <font class="keywordflow">return</font> *<font class="keyword">this</font> ;} ;
00110   Point_nD&amp; operator+=(<font class="keyword">const</font> Point_nD&amp; v) {x()+=v.x() ; y()+= v.y() ; <font class="keywordflow">return</font> *<font class="keyword">this</font>;} ;
00111   Point_nD&amp; operator-=(<font class="keyword">const</font> Point_nD&amp; v) {x()-=v.x() ; y()-= v.y() ;   <font class="keywordflow">return</font> *<font class="keyword">this</font>;} ;
00112   Point_nD&amp; operator*=(T v) {x()*=v ; y()*= v ; <font class="keywordflow">return</font> *<font class="keyword">this</font>;} ;
00113   Point_nD&amp; operator/=(T v) {x()/=v ; y()/= v ; <font class="keywordflow">return</font> *<font class="keyword">this</font>;} ;
00114  
00115   Point_nD unitLength()<font class="keyword"> const </font>{
00116           T d = norm(*<font class="keyword">this</font>) ;
00117     Point_nD&lt;T,2&gt; u(x()/d,y()/d) ;
00118     <font class="keywordflow">return</font> u ;
00119   }
00120 
00121 <font class="keyword">protected</font>:
00122   <font class="keyword">static</font> T dumbVar ; 
00123 };
00124 
00125 <font class="keyword">template</font>&lt;&gt;
00126 <font class="keyword">struct </font>Point_nD&lt;double,2&gt; { 
00127   <font class="keyword">typedef</font> <font class="keywordtype">double</font> T;
00128   T data[2] ;
00129   Point_nD()  { x() = y() = 0 ;}
00130   Point_nD(T a)  { x() = y() = a ;}
00131   Point_nD(T X, T Y)  {x()=X ; y()=Y ; }
00132   Point_nD(<font class="keyword">const</font> Point_nD&lt;T,2&gt;&amp; a)  { memcpy((<font class="keywordtype">void</font>*)data,(<font class="keywordtype">void</font>*)a.data,2*<font class="keyword">sizeof</font>(T));}
00133 
00134   <font class="keyword">inline</font> T&amp; x() { <font class="keywordflow">return</font> data[0] ; }
00135   <font class="keyword">inline</font> T&amp; y() { <font class="keywordflow">return</font> data[1] ; }
00136   <font class="keyword">inline</font> T&amp; z() { <font class="keywordflow">return</font> dumbVar ; }
00137   <font class="keyword">inline</font> T x()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[0] ; }
00138   <font class="keyword">inline</font> T y()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[1] ; }
00139   <font class="keyword">inline</font> T z()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> T() ; }
00140  
00141   Point_nD&amp; operator=(<font class="keyword">const</font> Point_nD&amp; v) { x()=v.x() ; y()=v.y() ; <font class="keywordflow">return</font> *<font class="keyword">this</font> ;} ;
00142   Point_nD&amp; operator+=(<font class="keyword">const</font> Point_nD&amp; v) {x()+=v.x() ; y()+= v.y() ; <font class="keywordflow">return</font> *<font class="keyword">this</font>;} ;
00143   Point_nD&amp; operator-=(<font class="keyword">const</font> Point_nD&amp; v) {x()-=v.x() ; y()-= v.y() ;   <font class="keywordflow">return</font> *<font class="keyword">this</font>;} ;
00144   Point_nD&amp; operator*=(T v) {x()*=v ; y()*= v ; <font class="keywordflow">return</font> *<font class="keyword">this</font>;} ;
00145   Point_nD&amp; operator/=(T v) {x()/=v ; y()/= v ; <font class="keywordflow">return</font> *<font class="keyword">this</font>;} ;
00146  
00147   Point_nD unitLength()<font class="keyword"> const </font>{
00148           T d = norm(*<font class="keyword">this</font>) ;
00149     Point_nD&lt;T,2&gt; u(x()/d,y()/d) ;
00150     <font class="keywordflow">return</font> u ;
00151   }
00152 
00153 <font class="keyword">protected</font>:
00154   <font class="keyword">static</font> T dumbVar ; 
00155 };
00156 
00157 
00158 <font class="keyword">template</font>&lt;&gt;
00159 <font class="keyword">struct </font>HPoint_nD&lt;float,3&gt; {
00160   <font class="keyword">typedef</font> <font class="keywordtype">float</font> T;
00161   T *data ; 
00162   <font class="keywordtype">int</font> created; <font class="comment">// usefull to change the data pointer</font>
00163 
00164   HPoint_nD(): data(new T[4]), created(1) { x() = y() = z() = w() = T(); }
00165   HPoint_nD(T *d,<font class="keywordtype">int</font> c): data(d), created(c) { ; } 
00166   HPoint_nD(T a): data(new T[4]), created(1) { x() = y() = z() = w() = a; }
00167   HPoint_nD(T X, T Y, T Z, T W):  data(new T[4]), created(1) { x()=X ; y()=Y; z()=Z; w()=W;}
00168   HPoint_nD(<font class="keyword">const</font> HPoint_nD&amp; a): data(new T[4]), created(1) { memcpy((<font class="keywordtype">void</font>*)data,(<font class="keywordtype">void</font>*)a.data,4*<font class="keyword">sizeof</font>(T)); }
00169   HPoint_nD(<font class="keyword">const</font> Point_nD&lt;T,3&gt;&amp; a): data(new T[4]), created(1) { memcpy((<font class="keywordtype">void</font>*)data,(<font class="keywordtype">void</font>*)a.data,(3)*<font class="keyword">sizeof</font>(T));  data[3] = T(1); }
00170   ~HPoint_nD() { <font class="keywordflow">if</font>(created) <font class="keywordflow">if</font>(data) <font class="keyword">delete</font> []data ; }
00171 
00172   <font class="keyword">inline</font> T&amp; x() { <font class="keywordflow">return</font> data[0] ;}
00173   <font class="keyword">inline</font> T x()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[0] ; }
00174   <font class="keyword">inline</font> T&amp; y() { <font class="keywordflow">return</font> data[1] ;}
00175   <font class="keyword">inline</font> T y()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[1] ;}
00176   <font class="keyword">inline</font> T&amp; z() { <font class="keywordflow">return</font> data[2] ;}
00177   <font class="keyword">inline</font> T z()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[2] ;}
00178   <font class="keyword">inline</font> T&amp; w() { <font class="keywordflow">return</font> data[3] ;}
00179   <font class="keyword">inline</font> T w()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[3] ;}
00180   
00181   HPoint_nD&lt;T,3&gt;&amp; operator=(<font class="keyword">const</font> HPoint_nD&lt;T,3&gt;&amp; v) {
00182     data[0] = v.data[0] ; 
00183     data[1] = v.data[1] ;
00184     data[2] = v.data[2] ;
00185     data[3] = v.data[3] ; 
00186     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00187   }
00188   HPoint_nD&lt;T,3&gt;&amp; operator=(<font class="keyword">const</font> Point_nD&lt;T,3&gt;&amp; v) {x()=v.x() ; y()=v.y() ; z()=v.z() ; w()=1.0 ; <font class="keywordflow">return</font> *<font class="keyword">this</font>;}
00189   HPoint_nD&lt;T,3&gt;&amp; operator=(<font class="keyword">const</font> T v) { x() = y() = z() = w() = v ; <font class="keywordflow">return</font> *<font class="keyword">this</font> ;} ;
00190   HPoint_nD&lt;T,3&gt;&amp; operator+=(<font class="keyword">const</font> HPoint_nD&lt;T,3&gt;&amp; v) {
00191     data[0] += v.data[0] ; 
00192     data[1] += v.data[1] ;
00193     data[2] += v.data[2] ;
00194     data[3] += v.data[3] ; 
00195     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00196   }
00197   HPoint_nD&lt;T,3&gt;&amp; operator-=(<font class="keyword">const</font> HPoint_nD&lt;T,3&gt;&amp; v) {
00198     data[0] -= v.data[0] ; 
00199     data[1] -= v.data[1] ;
00200     data[2] -= v.data[2] ;
00201     data[3] -= v.data[3] ; 
00202     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00203   }
00204 
00205   HPoint_nD&lt;T,3&gt;&amp; operator*=(T v) {
00206     data[0] *= v ; 
00207     data[1] *= v ;
00208     data[2] *= v ;
00209     data[3] *= v ; 
00210     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00211   }
00212   HPoint_nD&lt;T,3&gt;&amp; operator/=(T v)  {
00213     data[0] /= v ; 
00214     data[1] /= v ;
00215     data[2] /= v ;
00216     data[3] /= v ; 
00217     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00218   }
00219 
00220 
00221   <font class="keywordtype">void</font> move(<font class="keyword">const</font> Point_nD&lt;T,3&gt;&amp; m) ;
00222 
00223   Point_nD&lt;T,3&gt; projectW() { <font class="keywordflow">return</font> Point_nD&lt;T,3&gt;(x(),y(),z()) ; }
00224 };
00225 
00226 <font class="comment">//template &lt;class T&gt;</font>
00227 <font class="keyword">template</font>&lt;&gt;
00228 <font class="keyword">struct </font>HPoint_nD&lt;double,3&gt; {
00229   <font class="keyword">typedef</font> <font class="keywordtype">double</font> T;
00230   T *data ; 
00231   <font class="keywordtype">int</font> created; <font class="comment">// usefull to change the data pointer</font>
00232 
00233   HPoint_nD(): data(new T[4]), created(1) { x() = y() = z() = w() = T(); }
00234   HPoint_nD(T *d,<font class="keywordtype">int</font> c): data(d), created(c) { ; } 
00235   HPoint_nD(T a): data(new T[4]), created(1) { x() = y() = z() = w() = a; }
00236   HPoint_nD(T X, T Y, T Z, T W):  data(new T[4]), created(1) { x()=X ; y()=Y; z()=Z; w()=W;}
00237   HPoint_nD(<font class="keyword">const</font> HPoint_nD&amp; a): data(new T[4]), created(1) { memcpy((<font class="keywordtype">void</font>*)data,(<font class="keywordtype">void</font>*)a.data,4*<font class="keyword">sizeof</font>(T)); }
00238   HPoint_nD(<font class="keyword">const</font> Point_nD&lt;T,3&gt;&amp; a): data(new T[4]), created(1) { memcpy((<font class="keywordtype">void</font>*)data,(<font class="keywordtype">void</font>*)a.data,(3)*<font class="keyword">sizeof</font>(T));  data[3] = T(1); }
00239   ~HPoint_nD() { <font class="keywordflow">if</font>(created) <font class="keywordflow">if</font>(data) <font class="keyword">delete</font> []data ; }
00240 
00241   <font class="keyword">inline</font> T&amp; x() { <font class="keywordflow">return</font> data[0] ;}
00242   <font class="keyword">inline</font> T x()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[0] ; }
00243   <font class="keyword">inline</font> T&amp; y() { <font class="keywordflow">return</font> data[1] ;}
00244   <font class="keyword">inline</font> T y()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[1] ;}
00245   <font class="keyword">inline</font> T&amp; z() { <font class="keywordflow">return</font> data[2] ;}
00246   <font class="keyword">inline</font> T z()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[2] ;}
00247   <font class="keyword">inline</font> T&amp; w() { <font class="keywordflow">return</font> data[3] ;}
00248   <font class="keyword">inline</font> T w()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[3] ;}
00249   
00250   HPoint_nD&lt;T,3&gt;&amp; operator=(<font class="keyword">const</font> HPoint_nD&lt;T,3&gt;&amp; v) {
00251     data[0] = v.data[0] ; 
00252     data[1] = v.data[1] ;
00253     data[2] = v.data[2] ;
00254     data[3] = v.data[3] ; 
00255     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00256   }
00257 
00258   HPoint_nD&lt;T,3&gt;&amp; operator=(<font class="keyword">const</font> Point_nD&lt;T,3&gt;&amp; v) {x()=v.x() ; y()=v.y() ; z()=v.z() ; w()=1.0 ; <font class="keywordflow">return</font> *<font class="keyword">this</font>;}
00259   HPoint_nD&lt;T,3&gt;&amp; operator=(<font class="keyword">const</font> T v) { x() = y() = z() = w() = v ; <font class="keywordflow">return</font> *<font class="keyword">this</font> ;} ;
00260   HPoint_nD&lt;T,3&gt;&amp; operator+=(<font class="keyword">const</font> HPoint_nD&lt;T,3&gt;&amp; v) {
00261     data[0] += v.data[0] ; 
00262     data[1] += v.data[1] ;
00263     data[2] += v.data[2] ;
00264     data[3] += v.data[3] ; 
00265     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00266   }
00267 
00268   HPoint_nD&lt;T,3&gt;&amp; operator-=(<font class="keyword">const</font> HPoint_nD&lt;T,3&gt;&amp; v) {
00269     data[0] -= v.data[0] ; 
00270     data[1] -= v.data[1] ;
00271     data[2] -= v.data[2] ;
00272     data[3] -= v.data[3] ; 
00273     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00274   }
00275   HPoint_nD&lt;T,3&gt;&amp; operator*=(T v) {
00276     data[0] *= v ; 
00277     data[1] *= v ;
00278     data[2] *= v ;
00279     data[3] *= v ; 
00280     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00281   }
00282 
00283   HPoint_nD&lt;T,3&gt;&amp; operator/=(T v)  {
00284     data[0] /= v ; 
00285     data[1] /= v ;
00286     data[2] /= v ;
00287     data[3] /= v ; 
00288     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00289   }
00290 
00291 
00292   <font class="keywordtype">void</font> move(<font class="keyword">const</font> Point_nD&lt;T,3&gt;&amp; m) ;
00293 
00294   Point_nD&lt;T,3&gt; projectW() { <font class="keywordflow">return</font> Point_nD&lt;T,3&gt;(x(),y(),z()) ; }
00295 };
00296 
00297 <font class="keyword">template</font>&lt;&gt;
00298 <font class="keyword">struct </font>HPoint_nD&lt;float,2&gt; {
00299   <font class="keyword">typedef</font> <font class="keywordtype">float</font> T;
00300   T *data ; 
00301   <font class="keywordtype">int</font> created; <font class="comment">// usefull to change the data pointer</font>
00302 
00303   HPoint_nD(): data(new T[3]), created(1) { x() = y() = w() = T(); }
00304   HPoint_nD(T *d,<font class="keywordtype">int</font> c): data(d), created(c) { ; } 
00305   HPoint_nD(T a): data(new T[3]), created(1) { x() = y() = w() = a; }
00306   HPoint_nD(T X, T Y, T W):  data(new T[3]), created(1) { x()=X ; y()=Y; w()=W;}
00307   HPoint_nD(T X, T Y, T Z, T W):  data(new T[3]), created(1) { x()=X ; y()=Y; w()=W;}
00308   HPoint_nD(<font class="keyword">const</font> HPoint_nD&amp; a): data(new T[3]), created(1) { memcpy((<font class="keywordtype">void</font>*)data,(<font class="keywordtype">void</font>*)a.data,3*<font class="keyword">sizeof</font>(T)); }
00309   HPoint_nD(<font class="keyword">const</font> Point_nD&lt;T,2&gt;&amp; a): data(new T[3]), created(1) { memcpy((<font class="keywordtype">void</font>*)data,(<font class="keywordtype">void</font>*)a.data,(2)*<font class="keyword">sizeof</font>(T));  data[2] = T(1); }
00310   ~HPoint_nD() { <font class="keywordflow">if</font>(created) <font class="keywordflow">if</font>(data) <font class="keyword">delete</font> []data ; }
00311 
00312   <font class="keyword">inline</font> T&amp; x() { <font class="keywordflow">return</font> data[0] ;}
00313   <font class="keyword">inline</font> T x()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[0] ; }
00314   <font class="keyword">inline</font> T&amp; y() { <font class="keywordflow">return</font> data[1] ;}
00315   <font class="keyword">inline</font> T y()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[1] ;}
00316   <font class="keyword">inline</font> T&amp; z() { <font class="keywordflow">return</font>  dumbVar;}
00317   <font class="keyword">inline</font> T z()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> T(0) ;}
00318   <font class="keyword">inline</font> T&amp; w() { <font class="keywordflow">return</font> data[2] ;}
00319   <font class="keyword">inline</font> T w()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[2] ;}
00320   
00321 
00322   HPoint_nD&lt;T,2&gt;&amp; operator=(<font class="keyword">const</font> HPoint_nD&lt;T,2&gt;&amp; v) {
00323     data[0] = v.data[0] ; 
00324     data[1] = v.data[1] ;
00325     data[2] = v.data[2] ;
00326     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00327   }
00328 
00329   HPoint_nD&lt;T,2&gt;&amp; operator=(<font class="keyword">const</font> Point_nD&lt;T,2&gt;&amp; v) {x()=v.x() ; y()=v.y() ; w()=1.0 ; <font class="keywordflow">return</font> *<font class="keyword">this</font>;}
00330   HPoint_nD&lt;T,2&gt;&amp; operator=(<font class="keyword">const</font> T v) { x() = y() = w() = v ; <font class="keywordflow">return</font> *<font class="keyword">this</font> ;} ;
00331 
00332   HPoint_nD&lt;T,2&gt;&amp; operator*=(T v) {
00333     data[0] *= v ; 
00334     data[1] *= v ;
00335     data[2] *= v ;
00336     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00337   }
00338 
00339   HPoint_nD&lt;T,2&gt;&amp; operator/=(T v)  {
00340   data[0] /= v ; 
00341   data[1] /= v ;
00342   data[2] /= v ;
00343   <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00344 }
00345 
00346   HPoint_nD&lt;T,2&gt;&amp; operator-=(<font class="keyword">const</font> HPoint_nD&lt;T,2&gt;&amp; v) {
00347     data[0] -= v.data[0] ; 
00348     data[1] -= v.data[1] ;
00349     data[2] -= v.data[2] ;
00350     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00351   }
00352 
00353   HPoint_nD&lt;T,2&gt;&amp; operator+=(<font class="keyword">const</font> HPoint_nD&lt;T,2&gt;&amp; v) ; 
00354 
00355   <font class="keywordtype">void</font> move(<font class="keyword">const</font> Point_nD&lt;T,2&gt;&amp; m) ;
00356   Point_nD&lt;T,2&gt; projectW() { <font class="keywordflow">return</font> Point_nD&lt;T,2&gt;(x(),y()) ; }
00357 
00358 <font class="keyword">protected</font>:
00359   <font class="keyword">static</font> T dumbVar ;
00360 };
00361 
00362 <font class="keyword">template</font>&lt;&gt;
00363 <font class="keyword">struct </font>HPoint_nD&lt;double,2&gt; {
00364   <font class="keyword">typedef</font> <font class="keywordtype">double</font> T;
00365   T *data ; 
00366   <font class="keywordtype">int</font> created; <font class="comment">// usefull to change the data pointer</font>
00367 
00368   HPoint_nD(): data(new T[3]), created(1) { x() = y() = w() = T(); }
00369   HPoint_nD(T *d,<font class="keywordtype">int</font> c): data(d), created(c) { ; } 
00370   HPoint_nD(T a): data(new T[3]), created(1) { x() = y() = w() = a; }
00371   HPoint_nD(T X, T Y, T W):  data(new T[3]), created(1) { x()=X ; y()=Y; w()=W;}
00372   HPoint_nD(T X, T Y, T Z, T W):  data(new T[3]), created(1) { x()=X ; y()=Y; w()=W;}
00373   HPoint_nD(<font class="keyword">const</font> HPoint_nD&amp; a): data(new T[3]), created(1) { memcpy((<font class="keywordtype">void</font>*)data,(<font class="keywordtype">void</font>*)a.data,3*<font class="keyword">sizeof</font>(T)); }
00374   HPoint_nD(<font class="keyword">const</font> Point_nD&lt;T,2&gt;&amp; a): data(new T[3]), created(1) { memcpy((<font class="keywordtype">void</font>*)data,(<font class="keywordtype">void</font>*)a.data,(2)*<font class="keyword">sizeof</font>(T));  data[2] = T(1); }
00375   ~HPoint_nD() { <font class="keywordflow">if</font>(created) <font class="keywordflow">if</font>(data) <font class="keyword">delete</font> []data ; }
00376 
00377   <font class="keyword">inline</font> T&amp; x() { <font class="keywordflow">return</font> data[0] ;}
00378   <font class="keyword">inline</font> T x()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[0] ; }
00379   <font class="keyword">inline</font> T&amp; y() { <font class="keywordflow">return</font> data[1] ;}
00380   <font class="keyword">inline</font> T y()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[1] ;}
00381   <font class="keyword">inline</font> T&amp; z() { <font class="keywordflow">return</font>  dumbVar;}
00382   <font class="keyword">inline</font> T z()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> T(0) ;}
00383   <font class="keyword">inline</font> T&amp; w() { <font class="keywordflow">return</font> data[2] ;}
00384   <font class="keyword">inline</font> T w()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> data[2] ;}
00385   
00386 
00387   HPoint_nD&lt;T,2&gt;&amp; operator=(<font class="keyword">const</font> HPoint_nD&lt;T,2&gt;&amp; v) {
00388     data[0] = v.data[0] ; 
00389     data[1] = v.data[1] ;
00390     data[2] = v.data[2] ;
00391     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00392   }
00393 
00394 
00395   HPoint_nD&lt;T,2&gt;&amp; operator=(<font class="keyword">const</font> Point_nD&lt;T,2&gt;&amp; v) {x()=v.x() ; y()=v.y() ; w()=1.0 ; <font class="keywordflow">return</font> *<font class="keyword">this</font>;}
00396   HPoint_nD&lt;T,2&gt;&amp; operator=(<font class="keyword">const</font> T v) { x() = y() = w() = v ; <font class="keywordflow">return</font> *<font class="keyword">this</font> ;} ;
00397 
00398   HPoint_nD&lt;T,2&gt;&amp; operator*=(T v) {
00399     data[0] *= v ; 
00400     data[1] *= v ;
00401     data[2] *= v ;
00402     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00403   }
00404 
00405   HPoint_nD&lt;T,2&gt;&amp; operator/=(T v)  {
00406     data[0] /= v ; 
00407     data[1] /= v ;
00408     data[2] /= v ;
00409     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00410   }
00411  
00412   HPoint_nD&lt;T,2&gt;&amp; operator-=(<font class="keyword">const</font> HPoint_nD&lt;T,2&gt;&amp; v) {
00413     data[0] -= v.data[0] ; 
00414     data[1] -= v.data[1] ;
00415     data[2] -= v.data[2] ;
00416     <font class="keywordflow">return</font> *<font class="keyword">this</font> ;
00417   }
00418   HPoint_nD&lt;T,2&gt;&amp; operator+=(<font class="keyword">const</font> HPoint_nD&lt;T,2&gt;&amp; v) ; 
00419 
00420   <font class="keywordtype">void</font> move(<font class="keyword">const</font> Point_nD&lt;T,2&gt;&amp; m) ;
00421   Point_nD&lt;T,2&gt; projectW() { <font class="keywordflow">return</font> Point_nD&lt;T,2&gt;(x(),y()) ; }
00422 
00423 <font class="keyword">protected</font>:
00424   <font class="keyword">static</font> T dumbVar ;
00425 };
00426 
00427 
00428 
00429 <font class="preprocessor">#endif</font>
</pre></div><hr><address><small>Generated on Tue Jun 24 13:26:58 2003 for NURBS++ by
<a href="javascript:if(confirm('http://www.doxygen.org/index.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.doxygen.org/index.html'" tppabs="http://www.doxygen.org/index.html">
<img src="doxygen.gif" tppabs="http://libnurbs.sourceforge.net/docs/doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.14 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2002</small></address>
</body>
</html>
